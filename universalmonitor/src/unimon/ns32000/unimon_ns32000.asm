;;;
;;; Universal Monitor NS32000
;;;   Copyright (C) 2023 Haruo Asano
;;;

	INCLUDE	"config.inc"
	INCLUDE	"../common.inc"

	SUPMODE	ON

;;;
;;; ROM area
;;;
	
	ORG	0000H

CSTART:
	LPRD	SP,STACK
	INITCFG
	LPRD	SB,WORK_B
	LPRW	MOD,MODDSC
	LPRD	INTBASE,INTVEC

	BSR	INIT

	MOVD	RAM_B,R0
	MOVD	R0,@DSADDR
	MOVD	R0,@SADDR
	MOVD	R0,@GADDR
	MOVB	'S',@HEXMOD

	IF USE_REGCMD

	XORB	R0,R0
	MOVD	REG_B,R1
	MOVB	REG_E-REG_B,R2
INIR0:
	MOVB	R0,(R1)
	ADDQD	1,R1
	ACBB	-1,R2,INIR0
	
	MOVD	STACK,@REGSP0
	MOVD	USTACK,@REGSP1
	MOVW	MODDSC,@REGMOD
	MOVD	INTVEC,@REGINT
	MOVD	0300H,@REGPSR
	
	ENDIF

	MOVD	OPNMSG,R1
	BSR	STROUT

WSTART:
	MOVD	PROMPT,R1
	BSR	STROUT
	BSR	GETLIN
	MOVD	INBUF,R1
	BSR	SKIPSP
	MOVB	(R1),R0
	BSR	UPPER
	CMPB	00H,R0
	BEQ	WSTART

	CMPB	'D',R0
	BEQ	DUMP
	CMPB	'G',R0
	BEQ	GO
	CMPB	'S',R0
	BEQ	SETM

	CMPB	'L',R0
	BEQ	LOADH
	CMPB	'P',R0
	BEQ	SAVEH

	IF USE_REGCMD
	CMPB	'R',R0
	BEQ	REG
	ENDIF

ERR:
	MOVD	ERRMSG,R1
	BSR	STROUT
	BR	WSTART

;;; Dump memory

DUMP:
	ADDQD	1,R1
	BSR	SKIPSP
	BSR	RDHEX		; 1st arg.
	CMPB	0,R2
	BNE	DP0
	;; No arg.
	BSR	SKIPSP
	CMPB	00H,(R1)
	BNE	ERR
	MOVD	@DSADDR,R0
	ADDD	128,R0
	MOVD	R0,@DEADDR
	BR	DPM

	;; 1st arg. found
DP0:
	MOVD	R3,@DSADDR
	BSR	SKIPSP
	CMPB	',',(R1)
	BEQ	DP1
	CMPB	00H,(R1)
	BNE	ERR
	;; No 2nd arg.
	ADDD	128,R3
	MOVD	R3,@DEADDR
	BR	DPM

DP1:
	ADDQD	1,R1
	BSR	SKIPSP
	BSR	RDHEX
	BSR	SKIPSP
	CMPB	0,R2
	BEQ	ERR
	CMPB	00H,(R1)
	BNE	ERR
	ADDQD	1,R3
	MOVD	R3,@DEADDR

	;; DUMP main
DPM:
	MOVD	@DSADDR,R0
	ANDB	0F0H,R0
	MOVD	R0,R3
	XORB	R2,R2		; DSTATE
DPM0:
	BSR	DPL
	BSR	CONST
	CMPB	0,R0
	BNE	DPM1
	CMPB	2,R2		; DSTATE
	BHI	DPM0
	MOVD	@DEADDR,@DSADDR
	BR	WSTART
DPM1:
	MOVD	R3,@DSADDR
	BSR	CONIN
	BR	WSTART

	;; DUMP line
DPL:
	MOVD	R3,R0
	BSR	HEXOUT8
	MOVD	DSEP0,R1
	BSR	STROUT
	MOVD	INBUF,R4
	MOVB	16,R5
DPL0:
	BSR	DPB
	ACBB	-1,R5,DPL0

	MOVD	DSEP1,R1
	BSR	STROUT

	MOVD	INBUF,R4
	MOVB	16,R5
DPL1:
	MOVB	(R4),R0
	ADDQD	1,R4
	CMPB	' ',R0
	BHI	DPL2
	CMPB	7FH,R0
	BLS	DPL2
	BSR	CONOUT
	BR	DPL3
DPL2:
	MOVB	'.',R0
	BSR	CONOUT
DPL3:
	ACBB	-1,R5,DPL1
	BR	CRLF

	;; DUMP byte
DPB:
	MOVB	' ',R0
	BSR	CONOUT
	CMPB	0,R2		; DSTATE
	BNE	DPB2
	;; Dump state 0
	CMPD	@DSADDR,R3
	BEQ	DPB1
	;; Still 0 or 2
DPB0:
	MOVB	' ',R0
	MOVB	R0,(R4)
	BSR	CONOUT
	MOVB	' ',R0
	BSR	CONOUT
	ADDQD	1,R4
	ADDQD	1,R3
	RET
	;; Found start address
DPB1:
	MOVQB	1,R2		; DSTATE
DPB2:
	CMPB	1,R2		; DSTATE
	BNE	DPB0
	;; Dump state 1
	MOVB	(R3),R0
	MOVB	R0,(R4)
	ADDQD	1,R3
	ADDQD	1,R4
	BSR	HEXOUT2
	CMPD	@DEADDR,R3
	BEQ	DPB3
	RET
	;; Found end address
DPB3:
	MOVQB	2,R2		; DSTATE
	RET

;;; GO address

GO:
	ADDQD	1,R1
	BSR	SKIPSP
	BSR	RDHEX
	BSR	SKIPSP
	CMPB	00H,(R1)
	BNE	ERR
	CMPB	0,R2
	BEQ	G0

	IF USE_REGCMD

	MOVD	R3,@REGPC
G0:
	IF USE_FPU

	LFSR	@REGFSR
	MOVF	@REGF0,F0
	MOVF	@REGF1,F1
	MOVF	@REGF2,F2
	MOVF	@REGF3,F3
	MOVF	@REGF4,F4
	MOVF	@REGF5,F5
	MOVF	@REGF6,F6
	MOVF	@REGF7,F7

	ENDIF
	
	LPRD	INTBASE,@REGINT
	BISPSRW	0200H		; Set S flag to select SP1
	LPRD	SP,@REGSP1
	BICPSRW	0200H		; Clear S flag
	LPRD	SP,@REGSP0
	LPRD	FP,@REGFP	; Don't set SB.  It will be overwritten by RETT

	MOVW	@REGPSR,TOS
	MOVW	@REGMOD,TOS
	MOVD	@REGPC,TOS

	MOVD	@REGR7,R7
	MOVD	@REGR6,R6
	MOVD	@REGR5,R5
	MOVD	@REGR4,R4
	MOVD	@REGR3,R3
	MOVD	@REGR2,R2
	MOVD	@REGR1,R1
	MOVD	@REGR0,R0

	RETT

	ELSE
	
	MOVD	R3,@GADDR
G0:
	MOVD	@GADDR,R0
	JUMP	(R0)

	ENDIF

;;; SET memory

SETM:
	ADDQD	1,R1
	BSR	SKIPSP
	BSR	RDHEX
	BSR	SKIPSP
	CMPB	00H,(R1)
	BNE	ERR
	MOVD	R3,R4
	CMPB	0,R2
	BNE	SM0
	MOVD	@SADDR,R4
SM0:
SM1:
	MOVD	R4,R0
	BSR	HEXOUT8
	MOVD	DSEP1,R1
	BSR	STROUT
	MOVB	(R4),R0
	BSR	HEXOUT2
	MOVB	' ',R0
	BSR	CONOUT

	BSR	GETLIN
	MOVD	INBUF,R1
	BSR	SKIPSP
	MOVB	(R1),R0
	CMPB	00H,R0
	BNE	SM2
	;; Empty (Increment address)
	ADDQD	1,R4
	MOVD	R4,@SADDR
	BR	SM1
SM2:
	CMPB	'-',R0
	BNE	SM3
	;; '-' (Decrement address)
	ADDQD	-1,R4
	MOVD	R4,@SADDR
	BR	SM1
SM3:
	CMPB	'.',R0
	BNE	SM4
	;; '.' (Quit)
	MOVD	R4,@SADDR
	BR	WSTART
SM4:
	BSR	RDHEX
	CMPB	0,R2
	BEQ	ERR
	MOVB	R3,(R4)
	ADDQD	1,R4
	MOVD	R4,@SADDR
	BR	SM1

;;; LOAD HEX file

LOADH:
	ADDQD	1,R1
	BSR	SKIPSP
	BSR	RDHEX
	BSR	SKIPSP
	CMPB	00H,(R1)
	BNE	ERR

	CMPB	0,R2
	BNE	LH0

	XORD	R3,R3		; Offset (Is this really needed?)
LH0:
	BSR	CONIN
	BSR	UPPER
	CMPB	'S',R0
	BEQ	LHS0
LH1:
	CMPB	':',R0
	BEQ	LHI0
	;; Skip to EOL
LH2:
	CMPB	CR,R0
	BEQ	LH0
	CMPB	LF,R0
	BEQ	LH0
LH3:
	BSR	CONIN
	BR	LH2

	;; Intel HEX
LHI0:
	BSR	HEXIN
	MOVB	R0,R4		; Length
	MOVB	R0,R5		; Checksum

	BSR	HEXIN
	XORD	R2,R2
	MOVB	R0,R2		; Address H
	ADDB	R0,R5		; Checksum

	BSR	HEXIN
	LSHD	8,R2
	MOVB	R0,R2		; Address L
	ADDB	R0,R5		; Checksum

	;; Add Offset
	ADDD	R3,R2

	BSR	HEXIN
	MOVB	R0,R6		; RECTYP
	ADDB	R0,R5		; Checksum

	CMPB	0,R4
	BEQ	LHI3
LHI1:
	BSR	HEXIN
	ADDB	R0,R5		; Checksum

	CMPB	0,R6		; RECTYP
	BNE	LHI2

	MOVB	R0,(R2)
	ADDQD	1,R2
LHI2:
	ACBB	-1,R4,LHI1
LHI3:
	BSR	HEXIN
	ADDB	R0,R5		; Checksum
	CMPB	0,R5
	BNE	LHIE		; Checksum error
	CMPB	0,R6		; RECTYP
	BEQ	LH3
	BR	WSTART
LHIE:
	MOVD	IHEMSG,R1
	BSR	STROUT
	BR	WSTART

	;; Motorola S record
LHS0:
	BSR	CONIN
	XORB	R7,R7		; Clear end flag
	MOVQB	2,R6		; 2 byte address
	CMPB	'1',R0
	BEQ	LHS01
	CMPB	'9',R0
	BEQ	LHS00
	MOVQB	3,R6		; 3 byte address
	CMPB	'2',R0
	BEQ	LHS01
	CMPB	'8',R0
	BEQ	LHS00
	MOVQB	4,R6		; 4 byte address
	CMPB	'3',R0
	BEQ	LHS01
	CMPB	'7',R0
	BEQ	LHS00
	BR	LH3		; Skip unsupported record type
LHS00:
	MOVQB	1,R7		; RECTYP (end mark)
LHS01:
	BSR	HEXIN
	MOVB	R0,R4		; Length
	MOVB	R0,R5		; Checksum

	XORD	R2,R2
LHS02:
	BSR	HEXIN		; address
	LSHD	8,R2
	MOVB	R0,R2
	ADDB	R0,R5		; Checksum

	ADDQB	-1,R4
	ACBB	-1,R6,LHS02

	;; Add offset
	ADDD	R3,R2

	ADDQB	-1,R4
	CMPB	0,R4
	BEQ	LHS3
LHS1:
	BSR	HEXIN
	ADDB	R0,R5		; Checksum

	CMPB	0,R7
	BNE	LHS2		; End mark

	MOVB	R0,(R2)
	ADDQD	1,R2
LHS2:
	ACBB	-1,R4,LHS1
LHS3:
	BSR	HEXIN
	ADDB	R0,R5		; Checksum
	CMPB	0FFH,R5
	BNE	LHSE		; Checksum error

	CMPB	0,R7
	BEQ	LH3
	BR	WSTART
LHSE:
	MOVD	SHEMSG,R1
	BSR	STROUT
	BR	WSTART

;;; Save HEX file

SAVEH:
	ADDQD	1,R1
	MOVB	(R1),R0
	BSR	UPPER
	CMPB	'I',R0
	BEQ	SH0
	CMPB	'S',R0
	BEQ	SH0
	CMPB	'M',R0
	BEQ	SH0
	CMPB	'L',R0
	BNE	SH1
SH0:
	ADDQD	1,R1
	MOVB	R0,@HEXMOD
SH1:
	BSR	SKIPSP
	BSR	RDHEX
	CMPB	0,R2
	BEQ	ERR		; Start address missing
	MOVD	R3,R4		; R4 = Start address
	BSR	SKIPSP
	CMPB	',',(R1)
	BNE	ERR
	ADDQD	1,R1
	BSR	SKIPSP
	BSR	RDHEX
	CMPB	0,R2
	BEQ	ERR		; End address missing
	MOVD	R3,R5		; R5 = End address
	MOVD	R4,R6		; R6 = Default output address = start address
	BSR	SKIPSP
	CMPB	',',(R1)
	BNE	SH2
	ADDQD	1,R1
	BSR	SKIPSP
	BSR	RDHEX
	CMPB	0,R2
	BEQ	ERR		; Empty output address
	MOVD	R3,R6		; R6 = Output address
SH2:	
	CMPB	00H,(R1)
	BNE	ERR

	SUBD	R4,R5
	ADDQD	1,R5		; R5 = Length

	XORW	R7,R7		; Current upper address for IHEX
SH3:
	BSR	SHL
	CMPD	0,R5
	BNE	SH3

	CMPB	'I',@HEXMOD
	BNE	SH4
	;; End record for Intel HEX
	MOVD	IHEXER,R1
	BSR	STROUT
	BR	WSTART
SH4:
	;; End record for Motorola S record
	MOVD	SRECER,R1
	BSR	STROUT
	BR	WSTART

SHL:
	MOVD	16,R1
	MOVD	R6,R0
	ANDD	0FH,R0
	SUBD	R0,R1
	CMPD	R1,R5
	BLS	SHL0
	MOVD	R5,R1
SHL0:
	SUBD	R1,R5

	CMPB	'I',@HEXMOD
	BNE	SHLS

	;; Intel HEX
	MOVD	R6,R3
	LSHD	-16,R3
	CMPW	R3,R7
	BEQ	SHLI00
	MOVW	R3,R7
	;; Output 04 record
	MOVD	R1,TOS
	MOVD	IHEX04,R1
	BSR	STROUT
	MOVD	TOS,R1
	MOVB	2+4,R2		; Checksum

	MOVW	R3,R0
	LSHW	-8,R0		; Address [31:24]
	ADDB	R0,R2		; Checksum
	BSR	HEXOUT2

	MOVB	R3,R0		; Address [23:16]
	ADDB	R0,R2		; Checksum
	BSR	HEXOUT2

	NEGB	R2,R0		; Checksum
	BSR	HEXOUT2
	BSR	CRLF
SHLI00:	
	MOVB	':',R0
	BSR	CONOUT

	MOVB	R1,R0		; Length
	MOVB	R1,R2		; Checksum
	BSR	HEXOUT2

	MOVD	R6,R0
	ROTW	8,R0		; Address H
	ADDB	R0,R2		; Checksum
	BSR	HEXOUT2

	MOVB	R6,R0		; Address L
	ADDB	R0,R2		; Checksum
	BSR	HEXOUT2

	XORB	R0,R0		; Record type
	BSR	HEXOUT2

	ADDD	R1,R6
SHLI0:
	MOVB	(R4),R0
	ADDQD	1,R4
	ADDB	R0,R2		; Checksum
	BSR	HEXOUT2

	ACBB	-1,R1,SHLI0

	NEGB	R2,R0
	BSR	HEXOUT2
	BR	CRLF

SHLS:
	;; Motorola S record
	MOVB	'S',R0
	BSR	CONOUT

	MOVD	R6,R0
	LSHD	-24,R0
	CMPB	0,R0
	BNE	SHLS00		; Output address not fit in 24bit
	CMPB	'L',@HEXMOD
	BNE	SHLS01
SHLS00:
	MOVB	'3',R0
	MOVQD	4,R7
	BR	SHLS04
SHLS01:
	MOVD	R6,R0
	LSHD	-16,R0
	CMPB	0,R0
	BNE	SHLS02		; Output address not fit in 16bit
	CMPB	'M',@HEXMOD
	BNE	SHLS03
SHLS02:
	MOVB	'2',R0
	MOVQB	3,R7
	BR	SHLS04
SHLS03:
	MOVB	'1',R0
	MOVQD	2,R7
SHLS04:
	BSR	CONOUT

	MOVB	R1,R0		; Length
	ADDD	R7,R0		; + address length (2..4)
	ADDQB	1,R0		; + 1 (sum)
	MOVB	R0,R2		; Checksum
	BSR	HEXOUT2

	MOVD	R6,R0
SHLS05:
	MOVD	R0,TOS

	MOVD	R7,R3
	ADDQD	-1,R3
	LSHD	3,R3
	NEGD	R3,R3
	LSHD	R3,R0

	ADDB	R0,R2		; Checksum
	BSR	HEXOUT2
	
	MOVD	TOS,R0
	ACBB	-1,R7,SHLS05

	ADDD	R1,R6
SHLS0:
	MOVB	(R4),R0
	ADDQD	1,R4
	ADDB	R0,R2		; Checksum
	BSR	HEXOUT2

	ACBB	-1,R1,SHLS0

	COMB	R2,R0
	BSR	HEXOUT2
	BR	CRLF

;;; Register
	IF USE_REGCMD

REG:
	ADDQD	1,R1
	BSR	SKIPSP
	MOVB	(R1),R0
	BSR	UPPER
	CMPQB	0,R0
	BNE	RG0
	BSR	RDUMP
	BR	WSTART
RG0:
	MOVD	RNTAB,R2
RG1:
	CMPB	(R2),R0
	BEQ	RG2		; Character match
	CMPQB	0,1(R2)
	BEQ	RGE
	ADDD	10,R2
	BR	RG1
RG2:
	CMPB	0FH,1(R2)
	BNE	RG3
	;; Next table
	MOVD	2(R2),R2
	ADDQD	1,R1
	MOVB	(R1),R0
	BSR	UPPER
	BR	RG1
RG3:
	MOVB	1(R2),R4
	CMPQB	0,R4
	BEQ	RGE		; End mark found
	MOVD	6(R2),R1
	BSR	STROUT
	MOVB	'=',R0
	BSR	CONOUT
	MOVD	2(R2),R5	; reg. save area
	ANDB	07H,R4
	CMPB	1,R4
	BNE	RG4
	;; 8 bit register
	MOVB	(R5),R0
	BSR	HEXOUT2
	BR	RG6
RG4:
	CMPB	2,R4
	BNE	RG5
	;; 16 bit register
	MOVW	(R5),R0
	BSR	HEXOUT4
	BR	RG6
RG5:
	;; 32 bit register
	MOVD	(R5),R0
	BSR	HEXOUT8
RG6:
	MOVB	' ',R0
	BSR	CONOUT
	BSR	GETLIN
	MOVD	INBUF,R1
	BSR	SKIPSP
	BSR	RDHEX
	CMPQB	0,R2
	BEQ	RGR
	CMPB	1,R4
	BNE	RG7
	;; 8 bit register
	MOVB	R3,(R5)
	BR	RG9
RG7:
	CMPB	2,R4
	BNE	RG8
	;; 16 bit register
	MOVW	R3,(R5)
	BR	RG9
RG8:
	;; 32 bit register
	MOVD	R3,(R5)
RG9:
RGR:
	BR	WSTART
RGE:
	BR	ERR

RDUMP:
	MOVD	RDTAB,R2
RD0:
	MOVW	(R2),R3		; Flag
	ADDQD	2,R2
	CMPW	0,R3
	BEQ	CRLF		; END mark found => CR,LF and return
	MOVD	(R2),R1		; String address
	ADDQD	4,R2
	BSR	STROUT
	MOVD	(R2),R1		; Register save area
	ADDQD	4,R2
	ANDW	07H,R3
	CMPW	2,R3
	BNE	RD2
	;; WORD size
	MOVW	(R1),R0
	BSR	HEXOUT4
	BR	RD0
RD2:
	;; DWORD size
	MOVD	(R1),R0
	BSR	HEXOUT8
	BR	RD0

	ENDIF

;;; Other support routines

STROUT:
	MOVB	(R1),R0
	ADDQD	1,R1
	CMPB	0,R0
	BEQ	STROE
	BSR	CONOUT
	BR	STROUT
STROE:
	RET

HEXOUT8:
	MOVD	R0,TOS
	ROTD	16,R0
	BSR	HEXOUT4
	MOVD	TOS,R0
HEXOUT4:
	MOVD	R0,TOS
	ROTW	8,R0
	BSR	HEXOUT2
	MOVD	TOS,R0
HEXOUT2:
	MOVD	R0,TOS
	ROTB	4,R0
	BSR	HEXOUT1
	MOVD	TOS,R0
HEXOUT1:
	ANDB	0FH,R0
	ADDB	'0',R0
	CMPB	'9'+1,R0
	BHI	CONOUT
	ADDB	'A'-'9'-1,R0
	BR	CONOUT

HEXIN:
	XORB	R0,R0
	BSR	HI0
	LSHB	4,R0
HI0:
	MOVB	R0,TOS
	BSR	CONIN
	BSR	UPPER
	CMPB	'0',R0
	BHI	HIR
	CMPB	'9'+1,R0
	BHI	HI1
	CMPB	'A',R0
	BHI	HIR
	CMPB	'F'+1,R0
	BLS	HIR
	SUBB	'A'-'9'-1,R0
HI1:
	SUBB	'0',R0
	ORB	TOS,R0
	RET
HIR:
	MOVB	TOS,R0
	RET

CRLF:
	MOVB	CR,R0
	BSR	CONOUT
	MOVB	LF,R0
	BR	CONOUT

GETLIN:
	MOVD	INBUF,R1
	XORB	R2,R2
GL0:
	BSR	CONIN
	CMPB	CR,R0
	BEQ	GLE
	CMPB	LF,R0
	BEQ	GLE
	CMPB	BS,R0
	BEQ	GLB
	CMPB	DEL,R0
	BEQ	GLB
	CMPB	' ',R0
	BHI	GL0
	CMPB	80H,R0
	BLS	GL0
	CMPB	BUFLEN-1,R2
	BLS	GL0		; Too long
	ADDQB	1,R2
	MOVB	R0,(R1)
	ADDQD	1,R1
	BSR	CONOUT
	BR	GL0
GLB:
	CMPB	0,R2
	BEQ	GL0
	ADDQD	-1,R1
	ADDQB	-1,R2
	MOVB	BS,R0
	BSR	CONOUT
	MOVB	' ',R0
	BSR	CONOUT
	MOVB	BS,R0
	BSR	CONOUT
	BR	GL0
GLE:
	BSR	CRLF
	MOVB	00H,(R1)
	RET

SKIPSP:
	CMPB	' ',(R1)
	ADDQD	1,R1
	BEQ	SKIPSP
	ADDQD	-1,R1
	RET

UPPER:
	CMPB	'a',R0
	BHI	UPR
	CMPB	'z'+1,R0
	BLS	UPR
	ADDB	'A'-'a',R0
UPR:
	RET

RDHEX:
	XORB	R2,R2		; Count
	XORD	R3,R3		; Value
RH0:
	MOVB	(R1),R0
	BSR	UPPER
	CMPB	'0',R0
	BHI	RHE
	CMPB	'9'+1,R0
	BHI	RH1
	CMPB	'A',R0
	BHI	RHE
	CMPB	'F'+1,R0
	BLS	RHE
	SUBB	'A'-'9'-1,R0
RH1:
	SUBB	'0',R0
	LSHD	4,R3
	ORB	R0,R3
	ADDQD	1,R1
	ADDQB	1,R2
	BR	RH0
RHE:
	RET

;;; Exception Handler

	;; Dummy
DUMMY_H:
	RETT

NVI_H:	
	MOVB	0,@VECNUM
	BR	COMM_H

NMI_H:	
	MOVB	1,@VECNUM
	BR	COMM_H

ABT_H:	
	MOVB	2,@VECNUM
	BR	COMM_H

SLAVE_H:
	MOVB	3,@VECNUM
	BR	COMM_H

ILL_H:
	MOVB	4,@VECNUM
	BR	COMM_H

DVZ_H:
	MOVB	6,@VECNUM
	BR	COMM_H

FLG_H:
	MOVB	7,@VECNUM
	BR	COMM_H

BPT_H:
	MOVB	8,@VECNUM
	BR	COMM_H

TRC_H:
	MOVB	9,@VECNUM
	BR	COMM_H

UND_H:
	MOVB	10,@VECNUM
	BR	COMM_H

BER_H:	
	MOVB	12,@VECNUM
	BR	COMM_H

COMM_H:
	MOVD	TOS,@REGPC

	IF USE_REGCMD

	MOVD	R0,@REGR0
	MOVD	R1,@REGR1
	MOVD	R2,@REGR2
	MOVD	R3,@REGR3
	MOVD	R4,@REGR4
	MOVD	R5,@REGR5
	MOVD	R6,@REGR6
	MOVD	R7,@REGR7

	MOVW	TOS,@REGMOD
	MOVW	TOS,@REGPSR

	SPRD	SB,@REGSB
	SPRD	FP,@REGFP
	SPRD	SP,@REGSP0
	BISPSRW	0200H		; Set S flag to select SP1
	SPRD	SP,@REGSP1
	BICPSRW	0200H		; Clear S flag
	SPRD	INTBASE,@REGINT

	IF USE_FPU

	SFSR	@REGFSR
	MOVF	F0,@REGF0
	MOVF	F1,@REGF1
	MOVF	F2,@REGF2
	MOVF	F3,@REGF3
	MOVF	F4,@REGF4
	MOVF	F5,@REGF5
	MOVF	F6,@REGF6
	MOVF	F7,@REGF7

	ENDIF

	ELSE

	MOVD	TOS,R0		; Drop MOD & PSR on stack

	ENDIF

	MOVZBD	@VECNUM,R0
	LSHD	2,R0
	MOVD	TRPTAB(R0),R1
	BSR	STROUT
	MOVD	S_AT,R1
	BSR	STROUT

	MOVD	@REGPC,R0
	BSR	HEXOUT8
	BSR	CRLF
	BSR	RDUMP
	BR	WSTART

	;; Service Call
SVC_H:
	SAVE	[R6,R7]
	MOVD	8(SP),R6	; Get address of SVC instruction
	MOVB	1(R6),R7	; Service code
	ADDQD	2,R6		; Adjust return address
	MOVD	R6,8(SP)

	CMPB	6,R7
	BLS	SVC_HR
	MOVZBD	R7,R7
	LSHD	2,R7
	MOVD	SVCTAB(R7),R6
	JSR	(R6)

SVC_HR:
	RESTORE	[R6,R7]
	RETT

;;; Data area

OPNMSG:	DB	CR,LF,"Universal Monitor NS32000",CR,LF,0

PROMPT:	DB	"] ",0

IHEMSG:	DB	"Error ihex",CR,LF,0
SHEMSG:	DB	"Error srec",CR,LF,0
ERRMSG:	DB	"Error",CR,LF,0

DSEP0:	DB	" :",0
DSEP1:	DB	" : ",0
IHEXER:	DB	":00000001FF",CR,LF,0
SRECER:	DB	"S9030000FC",CR,LF,0
IHEX04:	DB	":02000004",0
S_AT:	DB	" at ",0

TRPTAB:
	DD	NVI_M
	DD	NMI_M
	DD	ABT_M
	DD	SLAVE_M

	DD	ILL_M
	DD	SVC_M
	DD	DVZ_M
	DD	FLG_M

	DD	BPT_M
	DD	TRC_M
	DD	UND_M
	DD	0

	DD	BER_M
	DD	0
	DD	0
	DD	0

NVI_M:
	DB	"Non-Vectored Interrupt",0
NMI_M:
	DB	"Non-Maskable Interrupt",0
ABT_M:
	DB	"Abort",0
SLAVE_M:
	DB	"Slave Processor Trap",0
ILL_M:
	DB	"Illegal Operation",0
SVC_M:
	DB	"Supervisor Call",0
DVZ_M:
	DB	"Division by Zero",0
FLG_M:
	DB	"Flag Trap",0
BPT_M:
	DB	"Break",0
TRC_M:
	DB	"Trace",0
UND_M:
	DB	"Undefined Instruction",0
BER_M:
	DB	"Bus Error",0

	IF USE_REGCMD

	ALIGN	2
RDTAB:	DW	3
	DD	RDSR07, REGR0
	DW	3
	DD	RDSC,   REGR1
	DW	3
	DD	RDSC,   REGR2
	DW	3
	DD	RDSC,   REGR3
	DW	3
	DD	RDSCS,  REGR4
	DW	3
	DD	RDSC,   REGR5
	DW	3
	DD	RDSC,   REGR6
	DW	3
	DD	RDSC,   REGR7

	DW	3
	DD	RDSPC,  REGPC
	DW	3
	DD	RDSSB,  REGSB
	DW	3
	DD	RDSFP,  REGFP
	DW	3
	DD	RDSSP1, REGSP1
	DW	2
	DD	RDSPSR, REGPSR

	DW	3
	DD	RDSINT, REGINT
	DW	3
	DD	RDSSP0, REGSP0
	DW	2
	DD	RDSMOD, REGMOD

	IF	USE_FPU

	DW	3
	DD	RDSF07, REGF0
	DW	3
	DD	RDSC,   REGF1
	DW	3
	DD	RDSC,   REGF2
	DW	3
	DD	RDSC,   REGF3
	DW	3
	DD	RDSCS,  REGF4
	DW	3
	DD	RDSC,   REGF5
	DW	3
	DD	RDSC,   REGF6
	DW	3
	DD	RDSC,   REGF7

	DW	3
	DD	RDSFSR, REGFSR

	ENDIF

	DW	0

	IF USE_FPU
RDSR07:	DB	"- CPU -",CR,LF,"R0-R7=",0
	ELSE
RDSR07:	DB	"R0-R7=",0
	ENDIF
RDSPC:	DB	CR,LF,"PC=",0
RDSSB:	DB	" SB=",0
RDSFP:	DB	" FP=",0
RDSSP1:	DB	" SP1=",0
RDSPSR:	DB	" PSR=",0
RDSINT:	DB	CR,LF,"INTBASE=",0
RDSSP0:	DB	" SP0=",0
RDSMOD:	DB	" MOD=",0
RDSC:	DB	",",0
RDSCS:	DB	", ",0
	IF USE_FPU
RDSF07:	DB	CR,LF,"- FPU -",CR,LF,"F0-F7=",0
RDSFSR:	DB	CR,LF,"FSR=",0
	ENDIF

	ALIGN	2
RNTAB:
	DB	'F',0FH		; "F?"
	DD	RNTABF,0
	DB	'I',0FH		; "I?"
	DD	RNTABI,0
	DB	'M',0FH		; "M?"
	DD	RNTABM,0
	DB	'P',0FH		; "P?"
	DD	RNTABP,0
	DB	'R',0FH		; "R?"
	DD	RNTABR,0
	DB	'S',0FH		; "S?"
	DD	RNTABS,0
	DB	'U',0FH		; "U?"
	DD	RNTABU,0

	DB	00H,00H
	DD	0,0

RNTABF:
	DB	'P',3		; "FP"
	DD	REGFP,RNFP

	IF USE_FPU

	DB	'0',3		; "F0"
	DD	REGF0,RNF0
	DB	'1',3		; "F1"
	DD	REGF1,RNF1
	DB	'2',3		; "F2"
	DD	REGF2,RNF2
	DB	'3',3		; "F3"
	DD	REGF3,RNF3
	DB	'4',3		; "F4"
	DD	REGF4,RNF4
	DB	'5',3		; "F5"
	DD	REGF5,RNF5
	DB	'6',3		; "F6"
	DD	REGF6,RNF6
	DB	'7',3		; "F7"
	DD	REGF7,RNF7
	DB	'S',0FH		; "FS?"
	DD	RNTABFS,0

	DB	00H,00H
	DD	0,0

RNTABFS:
	DB	'R',3		; "FSR"
	DD	REGFSR,RNFSR

	ENDIF

	DB	00H,00H
	DD	0,0

RNTABI:
	DB	'N',0FH		; "IN?"
	DD	RNTABIN
	
	DB	00H,00H
	DD	0,0

RNTABIN:
	DB	'T',3		; "INT"
	DD	REGINT,RNINT
	
	DB	00H,00H
	DD	0,0

RNTABM:
	DB	'O',0FH		; "MO?"
	DD	RNTABMO,0
	
	DB	00H,00H
	DD	0,0

RNTABMO:
	DB	'D',2		; "MOD"
	DD	REGMOD,RNMOD
	
	DB	00H,00H
	DD	0,0

RNTABP:
	DB	'C',3		; "PC"
	DD	REGPC,RNPC
	DB	'S',0FH		; "PS?"
	DD	RNTABPS,0
	
	DB	00H,00H
	DD	0,0

RNTABPS:
	DB	'R',2		; "PSR"
	DD	REGPSR,RNPSR
	
	DB	00H,00H
	DD	0,0

RNTABR:
	DB	'0',3		; "R0"
	DD	REGR0, RNR0
	DB	'1',3		; "R1"
	DD	REGR1, RNR1
	DB	'2',3		; "R2"
	DD	REGR2, RNR2
	DB	'3',3		; "R3"
	DD	REGR3, RNR3
	DB	'4',3		; "R4"
	DD	REGR4, RNR4
	DB	'5',3		; "R5"
	DD	REGR5, RNR5
	DB	'6',3		; "R6"
	DD	REGR6, RNR6
	DB	'7',3		; "R7"
	DD	REGR7, RNR7
	
	DB	00H,00H
	DD	0,0

RNTABS:
	DB	'B',3		; "SB"
	DD	REGSB,RNSB
	DB	'P',0FH		; "SP?"
	DD	RNTABSP,0
	
	DB	00H,00H
	DD	0,0

RNTABSP:
	DB	'0',3		; "SP0"
	DD	REGSP0, RNSP0
	DB	'1',3		; "SP1"
	DD	REGSP1, RNSP1
	
	DB	00H,00H
	DD	0,0

RNTABU:
	DB	'P',0FH		; "UP?"
	DD	RNTABUP,0
	
	DB	00H,00H
	DD	0,0

RNTABUP:
	DB	'S',0FH		; "UPS?"
	DD	RNTABUPS,0
	
	DB	00H,00H
	DD	0,0

RNTABUPS:
	DB	'R',1		; "UPSR"
	DD	REGPSR,RNUPSR
	
	DB	00H,00H
	DD	0,0

RNFP:	DB	"FP",0
RNINT:	DB	"INTBASE",0
RNMOD:	DB	"MOD",0
RNPC:	DB	"PC",0
RNR0:	DB	"R0",0
RNR1:	DB	"R1",0
RNR2:	DB	"R2",0
RNR3:	DB	"R3",0
RNR4:	DB	"R4",0
RNR5:	DB	"R5",0
RNR6:	DB	"R6",0
RNR7:	DB	"R7",0
RNSB:	DB	"SB",0
RNSP0:	DB	"SP0",0
RNSP1:	DB	"SP1",0
RNUPSR:	DB	"U"
RNPSR:	DB	"PSR",0

	IF USE_FPU

RNF0:	DB	"F0",0
RNF1:	DB	"F1",0
RNF2:	DB	"F2",0
RNF3:	DB	"F3",0
RNF4:	DB	"F4",0
RNF5:	DB	"F5",0
RNF6:	DB	"F6",0
RNF7:	DB	"F7",0
RNFSR:	DB	"FSR",0

	ENDIF

	ENDIF

;;; Module Descriptor

	ALIGN	4
MODDSC:
	DD	WORK_B		; Static base
	DD	00000000H	; Link base
	DD	00000000H	; Program base
	DD	00000000H

;;; Service call jump table

SVCTAB:
	DD	CSTART
	DD	WSTART
	DD	CONOUT
	DD	STROUT
	DD	CONIN
	DD	CONST
	
;;; Interrupt Dispatch Table

INTVEC:
	DW	MODDSC, NVI_H	; 0: Non-Vectored Interrupt
	DW	MODDSC, NMI_H	; 1: Non-Maskable Interrupt
	DW	MODDSC, ABT_H	; 2: Abort
	DW	MODDSC, SLAVE_H	; 3: Trap(SLAVE)

	DW	MODDSC, ILL_H	; 4: Trap(ILL)
	DW	MODDSC, SVC_H	; 5: Trap(SVC)
	DW	MODDSC, DVZ_H	; 6: Trap(DVZ)
	DW	MODDSC, FLG_H	; 7: Trap(FLG)

	DW	MODDSC, BPT_H	; 8: Trap(BPT)
	DW	MODDSC, TRC_H	; 9: Trap(TRC)
	DW	MODDSC, UND_H	; 10: Trap(UND)
	DW	MODDSC, DUMMY_H

	DW	MODDSC, BER_H	; 12: Bus Error
	DW	MODDSC, DUMMY_H
	DW	MODDSC, DUMMY_H
	DW	MODDSC, DUMMY_H

;;; Console driver
	
	IF USE_DEV_EMILY
	INCLUDE	"dev/dev_emily.asm"
	ENDIF

;;;
;;; RAM area
;;;

	ORG	WORK_B

INBUF:	DS	BUFLEN
DSADDR:	DS	4
DEADDR:	DS	4
SADDR:	DS	4
GADDR:	DS	4
HEXMOD:	DS	1

VECNUM:	DS	1

REG_B:
REGPC:	DS	4

	IF USE_REGCMD

REGR0:	DS	4
REGR1:	DS	4
REGR2:	DS	4
REGR3:	DS	4
REGR4:	DS	4
REGR5:	DS	4
REGR6:	DS	4
REGR7:	DS	4

REGSB:	DS	4
REGFP:	DS	4
REGSP0:	DS	4		; Interrupt Stack Pointer
REGSP1:	DS	4		; User Stack Pointer
REGINT:	DS	4		; INTBASE
REGCFG:	DS	4

REGMOD:	DS	2
REGPSR:	DS	2

	IF USE_FPU

REGFSR:	DS	4
REGF0:	DS	4
REGF1:	DS	4
REGF2:	DS	4
REGF3:	DS	4
REGF4:	DS	4
REGF5:	DS	4
REGF6:	DS	4
REGF7:	DS	4

	ENDIF

	ENDIF
REG_E:

	END

