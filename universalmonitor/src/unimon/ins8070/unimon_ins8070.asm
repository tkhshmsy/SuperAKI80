;;;
;;; Universal Monitor INS8070 (SC/MP III)
;;;   Copyright (C) 2021  Haruo Asano
;;;

	CPU	8070


	INCLUDE	"config.inc"

	INCLUDE	"../common.inc"

;;;
;;; ROM	area
;;;

	ORG	ROM_B
	
	NOP			; Dummy
	JMP	CSTART		; Reset

	IF ROM_B = 0x0000
	;; Fixed address area
	JMP	DUMMY		; INTA
	JMP	DUMMY		; INTB

	;; CALL vector
	ORG	0x0020
	
	DW	DUMMY-1		; CALL 0
	DW	DUMMY-1
	DW	DUMMY-1
	DW	DUMMY-1

	DW	DUMMY-1		; CALL 4
	DW	DUMMY-1
	DW	DUMMY-1
	DW	DUMMY-1

	DW	DUMMY-1		; CALL 8
	DW	DUMMY-1
	DW	DUMMY-1
	DW	DUMMY-1

	DW	DUMMY-1		; CALL 12
	DW	DUMMY-1
	DW	DUMMY-1
	DW	BREAK-1		; BREAK

	ORG	0x0040		; Skip vector for CALL instruction
	ENDIF

CSTART:
	IF ~~FOR_INS8073
	LD	SP,=STACK
	ENDIF

	JSR	INIT

	LD	P3,=WORK
	LD	EA,=RAM_B
	ST	EA,W_DSADDR,P3
	ST	EA,W_SADDR,P3
	ST	EA,W_GADDR,P3

	IF USE_REGCMD
	ST	EA,W_REGPC,P3
	LD	EA,SP
	ST	EA,W_REGSP,P3
	LD	EA,=0x0000
	ST	EA,W_REGEA,P3
	ST	EA,W_REGT,P3
	ST	EA,W_REGP2,P3
	ST	EA,W_REGP3,P3
	ST	A,W_REGS,P3
	ENDIF			; USE_REGCMD

	LD	A,='I'
	ST	A,W_HEXMOD,P3

	;; Opening message
	LD	P2,=OPNMSG
	JSR	STROUT

WSTART:
	LD	P2,=PROMPT
	JSR	STROUT
	JSR	GETLIN
	LD	P2,=WORK_INBUF
	JSR	SKIPSP
	JSR	UPPER
	BZ	WSTART
	LD	E,A		; backup A

	SUB	A,='D'
	BNZ	M00
	JMP	DUMP
M00:
	LD	A,E
	SUB	A,='G'
	BNZ	M01
	JMP	GO
M01:
	LD	A,E
	SUB	A,='S'
	BNZ	M02
	JMP	SETM
M02:
	LD	A,E
	SUB	A,='L'
	BNZ	M03
	JMP	LOADH
M03:
	LD	A,E
	SUB	A,='P'
	BNZ	M04
	JMP	SAVEH
M04:
	IF USE_REGCMD
	LD	A,E
	SUB	A,='R'
	BNZ	M05
	JMP	REG
M05:
	ENDIF			; USE_REGCMD

	IF FOR_INS8073
	LD	A,E
	SUB	A,='Q'
	BNZ	M09
	RET
M09:
	ENDIF

ERR:
	LD	P2,=ERRMSG
	JSR	STROUT
	JMP	WSTART

;;; Dump memory

DUMP:
	LD	A,@1,P2		; INC P2
	JSR	SKIPSP
	JSR	RDHEX
	LD	A,W_CNT,P3
	BNZ	DP0
	;; No arg.
	JSR	SKIPSP
	LD	A,0,P2
	BNZ	ERR
DP00:
	LD	EA,W_DSADDR,P3
	ADD	EA,=128
	ST	EA,W_DEADDR,P3
	BRA	DPM
	;; 1st arg. found
DP0:
	LD	EA,W_VAL,P3
	ST	EA,W_DSADDR,P3
	JSR	SKIPSP
	LD	A,0,P2
	SUB	A,=','
	BZ	DP1
	LD	A,0,P2
	BZ	DP00		; No 2nd arg.
	BRA	ERR
	;;
DP1:
	LD	A,@1,P2
	JSR	SKIPSP
	JSR	RDHEX
	JSR	SKIPSP
	LD	A,W_CNT,P3
	BZ	DP1E
	LD	A,0,P2
	BNZ	DP1E
	LD	EA,W_VAL,P3
	ADD	EA,=1
	ST	EA,W_DEADDR,P3
	BRA	DPM
DP1E:
	JMP	ERR
DPM:
	LD	EA,W_DSADDR,P3
	AND	A,=0xF0
	LD	P2,EA
	LD	A,=0
	ST	A,W_DSTATE,P3
DPM0:
	JSR	DPL
	JSR	CONST
	SUB	A,=1
	BZ	DPM1
	LD	A,W_DSTATE,P3
	SUB	A,=2
	BP	DPM01
	BRA	DPM0
DPM01:
	;; Finish
	LD	EA,W_DEADDR,P3
	ST	EA,W_DSADDR,P3
	JMP	WSTART
DPM1:
	;; Abort
	LD	EA,P2
	ST	EA,W_DSADDR,P3
	JSR	CONIN
	JMP	WSTART

	;; Dump line
DPL:
	LD	EA,P2
	PUSH	A
	LD	A,E
	JSR	HEXOUT2
	POP	A
	JSR	HEXOUT2
	PLI	P2,=DSEP0
	JSR	STROUT
	POP	P2

	LD	EA,=WORK_INBUF
	ST	EA,W_VAL,P3
	LD	A,=16
	ST	A,W_CNT,P3
DPL0:
	JSR	DPB
	DLD	A,W_CNT,P3
	BNZ	DPL0

	PLI	P2,=DSEP1
	JSR	STROUT
	POP	P2

	;; Print ASCII area
	PLI	P2,=WORK_INBUF
	LD	A,=16
	ST	A,W_CNT,P3
DPL1:
	LD	A,@1,P2
	SUB	A,=' '
	BP	DPL3
DPL2:
	;; Unprintable
	LD	A,='.'
	BRA	DPL4
DPL3:
	LD	A,-1,P2
	SUB	A,=0x7F
	BP	DPL2
	LD	A,-1,P2
DPL4:
	JSR	CONOUT
	DLD	A,W_CNT,P3
	BNZ	DPL1

	POP	P2
	JMP	CRLF

	;; Dump byte
DPB:
	LD	A,=' '
	JSR	CONOUT
	LD	A,W_DSTATE,P3
	BNZ	DPB2
	;; Dump state 0
	LD	EA,P2
	SUB	EA,W_DSADDR,P3
	BNZ	DPB0
	LD	A,E
	BZ	DPB1
	;; Still 0 or 2
DPB0:
	LD	A,=' '
	JSR	CONOUT
	LD	A,=' '
	JSR	CONOUT

	PUSH	P2
	LD	EA,W_VAL,P3
	LD	P2,EA
	LD	A,=' '
	ST	A,@1,P2
	LD	EA,P2
	ST	EA,W_VAL,P3
	POP	P2

	LD	EA,P2
	ADD	EA,=1
	LD	P2,EA
	RET

	;; Found start address
DPB1:
	LD	A,=1
	ST	A,W_DSTATE,P3
DPB2:
	LD	A,W_DSTATE,P3
	SUB	A,=1
	BNZ	DPB0
	;; Dump state 1
	LD	A,@1,P2
	PUSH	P2
	PUSH	A
	LD	EA,W_VAL,P3
	LD	P2,EA
	LD	A,0,SP
	ST	A,@1,P2
	LD	EA,P2
	ST	EA,W_VAL,P3
	POP	A
	POP	P2
	JSR	HEXOUT2

	LD	EA,P2
	SUB	EA,W_DEADDR,P3
	BNZ	DPBE
	LD	A,E
	BNZ	DPBE
	;; Found end address
	LD	A,=2
	ST	A,W_DSTATE,P3
DPBE:
	RET

;;; GO address

GO:
	LD	A,@1,P2		; INC P2
	JSR	SKIPSP
	JSR	RDHEX
	JSR	SKIPSP
	LD	A,0,P2
	BZ	GO0
	JMP	ERR
GO0:
	LD	A,W_CNT,P3
	BZ	G0
	LD	EA,W_VAL,P3

	IF USE_REGCMD

	ST	EA,W_REGPC,P3
G0:
	LD	EA,W_REGSP,P3
	LD	SP,EA
	LD	EA,W_REGPC,P3
	SUB	EA,=1
	PUSH	EA
	LD	EA,W_REGEA,P3
	PUSH	EA
	LD	EA,W_REGP3,P3
	PUSH	EA
	LD	EA,W_REGP2,P3
	LD	P2,EA
	LD	EA,W_REGT,P3
	LD	T,EA
	LD	A,W_REGS,P3
	LD	S,A
	POP	P3
	POP	EA
	RET

	ELSE			; USE_REGCMD
	
	ST	EA,W_GADDR,P3
G0:
	LD	EA,W_GADDR,P3
	SUB	EA,=1
	LD	PC,EA

	ENDIF			; USE_REGCMD

;;; Set memory

SETM:
	LD	A,@1,P2		; INC P2
	JSR	SKIPSP
	JSR	RDHEX
	JSR	SKIPSP
	LD	A,0,P2
	BZ	SM0
	JMP	ERR
SM0:
	LD	A,W_CNT,P3
	BZ	SM1
	LD	EA,W_VAL,P3
	ST	EA,W_SADDR,P3
SM1:
	LD	A,W_SADDR+1,P3
	JSR	HEXOUT2
	LD	A,W_SADDR,P3
	JSR	HEXOUT2

	LD	P2,=DSEP1
	JSR	STROUT

	LD	EA,W_SADDR,P3
	LD	P2,EA
	LD	A,0,P2
	JSR	HEXOUT2
	LD	A,=' '
	JSR	CONOUT

	JSR	GETLIN
	LD	P2,=WORK_INBUF
	JSR	SKIPSP
	LD	A,0,P2
	LD	E,A
	BNZ	SM2
	;; Empty (Increment address)
	LD	EA,W_SADDR,P3
	ADD	EA,=1
	ST	EA,W_SADDR,P3
	BRA	SM1
SM2:
	LD	A,E
	SUB	A,='-'
	BNZ	SM3
	;; '-' (Decrement address)
	LD	EA,W_SADDR,P3
	SUB	EA,=1
	ST	EA,W_SADDR,P3
	BRA	SM1
SM3:
	LD	A,E
	SUB	A,='.'
	BNZ	SM4
	;; '.' (Quit)
	JMP	WSTART
SM4:
	JSR	RDHEX
	LD	A,W_CNT,P3
	BNZ	SM5
	JMP	ERR
SM5:
	LD	EA,W_SADDR,P3
	LD	P2,EA
	ADD	EA,=1
	ST	EA,W_SADDR,P3
	LD	A,W_VAL,P3	; Low byte
	ST	A,0,P2
	BRA	SM1

;;; LOAD HEX file

LOADH:
	LD	A,@1,P2
	JSR	SKIPSP
	JSR	RDHEX
	JSR	SKIPSP
	LD	A,0,P2
	BNZ	LHE

LH0:	JSR	CONIN
	JSR	UPPER
	LD	E,A
	SUB	A,='S'
	BZ	LHS0
LH1:
	LD	A,E
	SUB	A,=':'
	BZ	LHI0
LH2:
	;; Skip to EOL
	LD	A,E
	SUB	A,=CR
	BZ	LH0
	LD	A,E
	SUB	A,=LF
	BZ	LH0
LH3:
	JSR	CONIN
	LD	E,A
	BRA	LH2
LHE:
	JMP	ERR

LHI0:
	JSR	HEXIN
	ST	A,W_SUM,P3
	ST	A,W_CNT,P3

	JSR	HEXIN
	LD	E,A		; Address H
	ADD	A,W_SUM,P3
	ST	A,W_SUM,P3

	JSR	HEXIN
	PUSH	A
	ADD	A,W_SUM,P3
	ST	A,W_SUM,P3
	POP	A		; Address L

	;; Add offset
	ADD	EA,W_VAL,P3
	LD	P2,EA

	JSR	HEXIN
	ST	A,W_RECTYP,P3
	ADD	A,W_SUM,P3
	ST	A,W_SUM,P3
	LD	A,W_RECTYP,P3
	SUB	A,=2
	BP	LH3		; Skip unsupported record type

	LD	A,W_CNT,P3
	BZ	LHI3
LHI1:
	JSR	HEXIN
	LD	E,A
	ADD	A,W_SUM,P3
	ST	A,W_SUM,P3

	LD	A,W_RECTYP,P3
	BNZ	LHI2

	LD	A,E
	ST	A,@1,P2
LHI2:
	DLD	A,W_CNT,P3
	BNZ	LHI1
LHI3:
	JSR	HEXIN
	ADD	A,W_SUM,P3
	BNZ	LHIE		; Checksum error
	LD	A,W_RECTYP,P3
	BZ	LH3
	JMP	WSTART
LHIE:
	LD	P2,=IHEMSG
	JSR	STROUT
	JMP	WSTART

LHS0:
	LD	A,=0
	ST	A,W_RECTYP,P3
	JSR	CONIN
	LD	E,A
	SUB	A,='1'
	BZ	LHS02
	LD	A,E
	SUB	A,='9'
	BZ	LHS01
	BRA	LH3		; Unsupported record type
LHS01:
	LD	A,=1
	ST	A,W_RECTYP,P3
LHS02:

	JSR	HEXIN
	ST	A,W_SUM,P3
	SUB	A,=3
	ST	A,W_CNT,P3

	JSR	HEXIN
	LD	E,A		; Address H
	ADD	A,W_SUM,P3
	ST	A,W_SUM,P3

	JSR	HEXIN
	PUSH	A
	ADD	A,W_SUM,P3
	ST	A,W_SUM,P3
	POP	A		; Address L

	;; Add offset
	ADD	EA,W_VAL,P3
	LD	P2,EA

	LD	A,W_CNT,P3
	BZ	LHS3
LHS1:
	JSR	HEXIN
	LD	E,A
	ADD	A,W_SUM,P3
	ST	A,W_SUM,P3

	LD	A,W_RECTYP,P3
	BNZ	LHS2

	LD	A,E
	ST	A,@1,P2
LHS2:
	DLD	A,W_CNT,P3
	BNZ	LHS1
LHS3:

	JSR	HEXIN
	ADD	A,W_SUM,P3
	SUB	A,=0xFF
	BNZ	LHSE		; Checksum error

	LD	A,W_RECTYP,P3
	BNZ	LHSR
	JMP	LH3
LHSE:
	LD	P2,=SHEMSG
	JSR	STROUT
LHSR:
	JMP	WSTART

;;; SAVE HEX file

SAVEH:
	LD	A,@1,P2
	LD	A,0,P2
	JSR	UPPER
	LD	E,A
	SUB	A,='I'
	BZ	SH0
	LD	A,E
	SUB	A,='S'
	BNZ	SH1
SH0:
	LD	A,@1,P2
	LD	A,E
	ST	A,W_HEXMOD,P3
SH1:
	JSR	SKIPSP
	JSR	RDHEX
	LD	A,W_CNT,P3
	BZ	SHE		; Start address missing
	LD	EA,W_VAL,P3
	PUSH	EA		; Start address
	JSR	SKIPSP
	LD	A,@1,P2
	SUB	A,=','
	BNZ	SHEP
	JSR	SKIPSP
	JSR	RDHEX
	LD	A,W_CNT,P3
	BZ	SHEP		; End address missing
	LD	T,W_VAL,P3	; T = End address
	JSR	SKIPSP
	LD	A,0,P2
	BZ	SH2
SHEP:
	POP	EA		; Drop start address on stack
SHE:
	JMP	ERR

SH2:
	POP	EA		; Start address
	LD	P2,EA
	ST	EA,W_VAL,P3
	LD	EA,T
	SUB	EA,W_VAL,P3	; <end> - <start>
	ADD	EA,=1
	LD	T,EA		; T = Length
SH3:	
	JSR	SHL
	LD	EA,T
	OR	A,E
	BNZ	SH3

	LD	A,W_HEXMOD,P3
	SUB	A,='I'
	BNZ	SH4
	;; End record for Intel HEX
	LD	P2,=IHEXER
	JSR	STROUT
	JMP	WSTART
SH4:
	;; End record for Motorola S record
	LD	P2,=SRECER
	JSR	STROUT
	JMP	WSTART

SHL:
	LD	A,=16
	ST	A,W_CNT,P3
	LD	EA,T
	AND	A,=0xF0
	BNZ	SHL0		; T >= 16
	LD	A,E
	BNZ	SHL0		; T >= 16
	LD	EA,T
	ST	A,W_CNT,P3
	LD	EA,=0
	LD	T,EA
	BRA	SHL1
SHL0:
	LD	EA,=16
	ST	EA,W_VAL,P3
	LD	EA,T
	SUB	EA,W_VAL,P3
	LD	T,EA		; T = T - 16
SHL1:
	LD	A,W_HEXMOD,P3
	SUB	A,='I'
	BNZ	SHLS

	;; Intel HEX
	LD	A,=':'
	JSR	CONOUT

	LD	A,W_CNT,P3
	ST	A,W_SUM,P3	; Checksum
	JSR	HEXOUT2		; Length

	LD	EA,P2
	LD	A,E
	ADD	A,W_SUM,P3
	ST	A,W_SUM,P3	; Checksum
	LD	A,E
	JSR	HEXOUT2		; Address H

	LD	EA,P2
	LD	E,A
	ADD	A,W_SUM,P3
	ST	A,W_SUM,P3
	LD	A,E
	JSR	HEXOUT2		; Address L

	LD	A,=0
	JSR	HEXOUT2		; Record type
SHLI0:
	LD	A,@1,P2
	LD	E,A
	ADD	A,W_SUM,P3
	ST	A,W_SUM,P3
	LD	A,E
	JSR	HEXOUT2

	DLD	A,W_CNT,P3
	BNZ	SHLI0

	LD	A,=0
	SUB	A,W_SUM,P3
	JSR	HEXOUT2
	JMP	CRLF

SHLS:
	;; Motorola S record
	LD	A,='S'
	JSR	CONOUT
	LD	A,='1'
	JSR	CONOUT

	LD	A,W_CNT,P3
	ADD	A,=3		; DataLength + 2 (addr) + 1 (sum)
	ST	A,W_SUM,P3
	JSR	HEXOUT2

	LD	EA,P2
	LD	A,E
	ADD	A,W_SUM,P3
	ST	A,W_SUM,P3
	LD	A,E
	JSR	HEXOUT2		; Address H

	LD	EA,P2
	LD	E,A
	ADD	A,W_SUM,P3
	ST	A,W_SUM,P3
	LD	A,E
	JSR	HEXOUT2		; Address L

SHLS0:
	LD	A,@1,P2
	LD	E,A
	ADD	A,W_SUM,P3
	ST	A,W_SUM,P3
	LD	A,E
	JSR	HEXOUT2

	DLD	A,W_CNT,P3
	BNZ	SHLS0

	LD	A,W_SUM,P3
	XOR	A,=0xFF
	JSR	HEXOUT2
	JMP	CRLF

;;; Register

	IF USE_REGCMD

REG:
	LD	A,@1,P2
	JSR	SKIPSP
	JSR	UPPER
	BNZ	RG0
	JSR	RDUMP
	JMP	WSTART
RG0:
	LD	P3,=RNTAB
RG1:
	LD	E,A
	XOR	A,@1,P3
	BZ	RG2		; Character match
	LD	A,0,P3
	BZ	RGE		; Found end mark
	LD	A,@5,P3
	LD	A,E
	BRA	RG1
RG2:
	LD	A,@1,P3
	LD	E,A
	SUB	A,=0x0F		; Link code
	BNZ	RG3
	;; Next table
	LD	EA,0,P3
	LD	P3,EA
	LD	A,@1,P2
	LD	A,0,P2
	JSR	UPPER
	BRA	RG1
RG3:
	LD	A,E
	BZ	RGE		; Found end mark
	AND	A,=0x07
	PUSH	A
	LD	EA,@2,P3
	PUSH	EA		; Reg storage address
	LD	EA,0,P3
	LD	P2,EA		; Reg name
	JSR	STROUT
	LD	A,='='
	JSR	CONOUT
	LD	A,2,SP
	SUB	A,=1
	BNZ	RG4
	;; 8 bit register
	POP	P2
	LD	A,0,P2
	PUSH	P2
	JSR	HEXOUT2
	BRA	RG5
RG4:
	;; 16 bit register
	POP	P2
	LD	EA,0,P2
	PUSH	P2
	PUSH	EA
	LD	A,E
	JSR	HEXOUT2
	POP	EA
	JSR	HEXOUT2
RG5:
	LD	A,=' '
	JSR	CONOUT
	LD	P3,=WORK
	JSR	GETLIN
	LD	P2,=WORK_INBUF
	JSR	SKIPSP
	JSR	RDHEX
	LD 	A,W_CNT,P3
	BZ	RGR
	LD	A,2,SP
	SUB	A,=1
	BNZ	RG6
	;; 8 bit register
	POP	P2
	LD	A,W_VAL,P3
	ST	A,0,P2
	BRA	RG7
RG6:
	;; 16 bit register
	POP	P2
	LD	EA,W_VAL,P3
	ST	EA,0,P2
RG7:
	POP	A
	JMP	WSTART
RGR:
	POP	P2
	BRA	RG7
RGE:
	LD	P3,=WORK
	JMP	ERR
	
RDUMP:
	LD	P2,=RDTAB
RD0:
	LD	EA,@2,P2
	LD	T,EA
	OR	A,E
	BZ	RDR
	PUSH	P2
	LD	EA,T
	LD	P2,EA
	JSR	STROUT
	POP	P2
	LD	T,@2,P2
	LD	A,@1,P2
	SUB	A,=1
	BNZ	RD1
	;; 1 byte
	LD	EA,T
	PUSH	P2
	LD	P2,EA
	LD	A,0,P2
	POP	P2
	JSR	HEXOUT2
	BRA	RD0
RD1:
	;; 2 byte
	LD	EA,T
	PUSH	P2
	LD	P2,EA
	LD	T,0,P2
	POP	P2
	LD	EA,T
	LD	A,E
	JSR	HEXOUT2
	LD	EA,T
	JSR	HEXOUT2
	BRA	RD0
RDR:
	JMP	CRLF

	ENDIF			; USE_REGCMD

;;; Other support routines

STROUT:
	LD	A,@+1,P2
	BZ	STROR
	JSR	CONOUT
	BRA	STROUT
STROR:
	RET

HEXOUT2:
	PUSH	A
	SR	A
	SR	A
	SR	A
	SR	A
	JSR	HEXOUT1
	POP	A
HEXOUT1:
	PUSH	EA
	AND	A,=0x0F
	ADD	A,='0'
	LD	E,A
	SUB	A,='9'+1
	BP	HEXOUT0
	LD	A,E
HEXOUTE:
	JSR	CONOUT
	POP	EA
	RET
HEXOUT0:
	LD	A,E
	ADD	A,='A'-'9'-1
	BRA	HEXOUTE

HEXIN:
	LD	A,=0
	JSR	HI0
	SL	A
	SL	A
	SL	A
	SL	A
HI0:
	PUSH	EA
	JSR	CONIN
	JSR	UPPER
	LD	E,A
	SUB	A,='F'+1
	BP	HIR
	LD	A,E
	SUB	A,='A'
	BP	HI2
	LD	A,E
	SUB	A,='9'+1
	BP	HIR
	LD	A,E
	SUB	A,='0'
	BP	HI1
HIR:
	POP	EA
	RET
HI1:
	LD	A,E
	SUB	A,='0'
	BRA	HI3
HI2:
	LD	A,E
	SUB	A,='A'-10
HI3:
	OR	A,0,SP
	ST	A,0,SP
	BRA	HIR
	
CRLF:
	LD	A,=CR
	JSR	CONOUT
	LD	A,=LF
	JMP	CONOUT

GETLIN:
	LD	P2,=WORK_INBUF
	LD	A,=0
	ST	A,W_CNT,P3
GL0:
	JSR	CONIN
	LD	E,A
	SUB	A,=CR
	BZ	GLE
	LD	A,E
	SUB	A,=LF
	BNZ	GL1
GLE:
	JSR	CRLF
	LD	A,=0
	ST	A,0,P2
	RET
GL1:	
	LD	A,E
	SUB	A,=BS
	BZ	GLB
	LD	A,E
	SUB	A,=DEL
	BNZ	GL2
GLB:
	LD	A,W_CNT,P3
	BZ	GL0
	SUB	A,=1
	ST	A,W_CNT,P3
	LD	A,@-1,P2	; DEC P2
	LD	A,=BS
	JSR	CONOUT
	LD	A,=' '
	JSR	CONOUT
	LD	A,=BS
	JSR	CONOUT
	BRA	GL0
GL2:
	LD	A,E
	SUB	A,=' '
	BP	GL3
	BRA	GL0		; 0x00-0x1F
GL3:
	LD	A,E
	SUB	A,=0x7F
	BP	GL0		; 0x7F-0xFF
	LD	A,W_CNT,P3
	SUB	A,=BUFLEN-1
	BP	GL0
	ILD	A,W_CNT,P3	; INC CNT
	LD	A,E
	ST	A,@1,P2
	JSR	CONOUT
	BRA	GL0

SKIPSP:
	LD	A,@1,P2
	SUB	A,=' '
	BZ	SKIPSP
	LD	A,@-1,P2
	RET

UPPER:
	LD	E,A
	SUB	A,='a'
	BP	UP0
	BRA	UPR
UP0:
	LD	A,E
	SUB	A,='z'+1
	BP	UPR
	LD	A,E
	ADD	A,='A'-'a'
	RET
UPR:
	LD	A,E
	RET

RDHEX:
	LD	EA,=0
	ST	A,W_CNT,P3
	ST	EA,W_VAL,P3
RH0:
	LD	A,@1,P2
	JSR	UPPER
	LD	E,A
	SUB	A,='0'
	BP	RH01
	BRA	RHE
RH01:
	LD	A,E
	SUB	A,='9'+1
	BP	RH02
	LD	A,E
	BRA	RH1
RH02:
	LD	A,E
	SUB	A,='A'
	BP	RH03
	BRA	RHE
RH03:
	LD	A,E
	SUB	A,='F'+1
	BP	RHE
	LD	A,E
	SUB	A,='A'-'9'-1
RH1:
	SUB	A,='0'
	PUSH	A
	LD	EA,W_VAL,P3
	SL	EA
	SL	EA
	SL	EA
	SL	EA
	OR	A,0,SP
	ST	EA,W_VAL,P3
	POP	A		; Drop
	ILD	A,W_CNT,P3
	BRA	RH0
RHE:
	LD	A,@-1,P2	; DEC P2
	RET

DUMMY:
	RET

;;;  BREAK

BREAK:
	IF USE_REGCMD

	PUSH	EA
	PLI	P3,=WORK
	LD	A,S
	ST	A,W_REGS,P3
	LD	EA,T
	ST	EA,W_REGT,P3
	LD	EA,P2
	ST	EA,W_REGP2,P3
	POP	EA
	ST	EA,W_REGP3,P3
	POP	EA
	ST	EA,W_REGEA,P3
	POP	EA
	ST	EA,W_REGPC,P3
	LD	EA,SP
	ST	EA,W_REGSP,P3

	LD	P2,=BRKMSG
	JSR	STROUT
	JSR	RDUMP
	JMP	WSTART

	ELSE			; USE_REGCMD

	RET

	ENDIF			; USE_REGCMD

;;; Data area

OPNMSG:
	DB	CR,LF,"Universal Monitor INS8070",CR,LF,0x00
PROMPT:
	DB	"] ",0x00

IHEMSG:
	DB	"Error ihex",CR,LF,0x00
SHEMSG:
	DB	"Error srec",CR,LF,0x00
ERRMSG:
	DB	"Error",CR,LF,0x00

DSEP0:
	DB	" :",0x00
DSEP1:
	DB	" : ",0x00
IHEXER:
        DB	":00000001FF",CR,LF,0x00
SRECER:
        DB	"S9030000FC",CR,LF,0x00

BRKMSG:
	DB	"BREAK",CR,LF,0x00

	IF USE_REGCMD

RDTAB:
	DW	RDSEA,  WORK_REGEA
	DB	2
	DW	RDST,   WORK_REGT
	DB	2
	DW	RDSS,   WORK_REGS
	DB	1
	DW	RDSPC,  WORK_REGPC
	DB	2
	DW	RDSSP,  WORK_REGSP
	DB	2
	DW	RDSP2,  WORK_REGP2
	DB	2
	DW	RDSP3,  WORK_REGP3
	DB	2

	DW	0x0000, 0x0000
	DB	0

RDSEA:	DB	"EA=",0x00
RDST:	DB	" T=",0x00
RDSS:	DB	" S=",0x00
RDSPC:	DB	"  PC=",0x00
RDSSP:	DB	" SP=",0x00
RDSP2:	DB	" P2=",0x00
RDSP3:	DB	" P3=",0x00

RNTAB:
	DB	'A',1		; "A"
	DW	WORK_REGEA,RNA
	DB	'E',0x0F	; "E?"
	DW	RNTABE,0
	DB	'P',0x0F	; "P?"
	DW	RNTABP,0
	DB	'S',0x0F	; "S?"
	DW	RNTABS,0
	DB	'T',2		; "A"
	DW	WORK_REGT,RNT

	DB	0x00,0

RNTABE:
	DB	0x00,1		; "E"
	DW	WORK_REGEA+1,RNE
	DB	'A',2		; "EA"
	DW	WORK_REGEA,RNEA

	DB	0x00,0

RNTABP:
	DB	'2',2		; "P2"
	DW	WORK_REGP2,RNP2
	DB	'3',2		; "P3"
	DW	WORK_REGP3,RNP3
	DB	'C',2		; "PC"
	DW	WORK_REGPC,RNPC

	DB	0x00,0

RNTABS:
	DB	0x00,1		; "S"
	DW	WORK_REGS,RNS
	DB	'P',2		; "SP"
	DW	WORK_REGSP,RNSP

	DB	0x00,0

RNA:	DB	"A",0x00
RNE:	DB	"E",0x00
RNEA:	DB	"EA",0x00
RNP2:	DB	"P2",0x00
RNP3:	DB	"P3",0x00
RNPC:	DB	"PC",0x00
RNS:	DB	"S",0x00
RNSP:	DB	"SP",0x00
RNT:	DB	"T",0x00

	ENDIF			; USE_REGCMD

;;; Console drivers

	IF USE_DEV_EMILY
	INCLUDE	"dev/dev_emily.asm"
	ENDIF

	IF USE_DEV_INS8073
	INCLUDE	"dev/dev_ins8073.asm"
	ENDIF

;;; Entry point from NSC Tiny BASIC

	IF CONSOLE_FOR_BASIC

BAS_CONIN:
	JSR	CONST
	BZ	BCIN0

	JSR	CONIN
	AND	A,=0x7F
	PUSH	A
	JSR	CONOUT
	POP	A
BCIN0:
	RET

BAS_CONOUT:
	AND	A,=0x7F
	JMP	CONOUT

	ORG	0xFD00

	DB	0x00		; FD00
	DW	BAS_CONIN	; FD01,FD02
	DW	BAS_CONOUT	; FD03,FD04

	ENDIF

	IF USE_DEV_INS8073

	ORG	0xFD00

	DB	0x80		; FD00

	ENDIF

;;;
;;; RAM area
;;;

	;; Work area

	ORG	WORK_B

W	STRUCT	NOEXTNAMES
	
INBUF:	DS	BUFLEN		; Line input buffer
DSADDR:	DS	2		; Dump start address
DEADDR:	DS	2		; Dump end address
DSTATE:	DS	1		; Dump state
GADDR:	DS	2		; Go address
SADDR:	DS	2		; Set address
HEXMOD:	DS	1		; HEX file mode

VAL:	DS	2		; Generic 16bit value
CNT:	DS	1		; Generic Counter
SUM:	DS	1		; Checksum
RECTYP:	DS	1		; Record type

	IF USE_REGCMD

REGEA:	DS	2
REGT:	DS	2
REGS:	DS	1
REGPC:	DS	2
REGSP:	DS	2
REGP2:	DS	2
REGP3:	DS	2

	ENDIF			; USE_REGCMD

W	ENDSTRUCT

WORK	W

	IFDEF MEMREQ
DEVMEM:	DS	MEMREQ
	ENDIF

	END
