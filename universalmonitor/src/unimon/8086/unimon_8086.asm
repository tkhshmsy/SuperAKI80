;;;
;;; Universal Monitor 8086
;;;   Copyright (C) 2020 Haruo Asano
;;;

	CPU	8086

TARGET:	EQU	"8086"

	INCLUDE	"config.inc"

	INCLUDE "../common.inc"


	ASSUME	CS:CODE, DS:DATA, SS:DATA, ES:NOTHING

;;;
;;; ROM area
;;;

	SEGMENT	CODE
	
	ORG	ROM_B

CSTART:
	MOV	AX,RAMSEG
	MOV	DS,AX
	MOV	SS,AX
	MOV	SP,STACK

	;; 
	
	CALL	INIT

	MOV	AX,RAMSEG
	MOV	[CURSEG],AX
	IF RAMSEG = 0
	MOV	AX,VECSIZ*4
	ELSE
	XOR	AX,AX
	ENDIF
	MOV	[DSADDR],AX
	MOV	[GADDR],AX
	MOV	[SADDR],AX
	MOV	AL,'I'
	MOV	[HEXMOD],AL
	XOR	AL,AL
	MOV	[PSPEC],AL

	IF USE_REGCMD

	;; Initialize register value
	XOR	AX,AX
	MOV	BX,REG_B
	MOV	CX,(REG_E - REG_B)/2
IR0:
	MOV	[BX],AX
	INC	BX
	INC	BX
	DEC	CX
	JNE	IR0

	MOV	AX,RAMSEG
	MOV	[REGDS],AX
	MOV	[REGSS],AX
	MOV	AX,STACK
	MOV	[REGSP],AX

	ENDIF
	
	;; Initialize vector
	XOR	AX,AX
	MOV	ES,AX
	MOV	SI,INIVEC
	MOV	DI,AX
	MOV	CX,VECSIZ*2
INI0:	
	MOV	AX,CS:[SI]
	INC	SI
	INC	SI
	MOV	ES:[DI],AX
	INC	DI
	INC	DI
	DEC	CX
	JZ	INI2
	CMP	SI,INIVECE
	JNZ	INI0
	MOV	AX,INTDMY
	MOV	BX,ROMSEG
INI1:
	MOV	ES:[DI],AX
	INC	DI
	INC	DI
	MOV	ES:[DI],BX
	INC	DI
	INC	DI
	DEC	CX
	DEC	CX
	JNZ	INI1
INI2:

	;; Opening message
	MOV	BX,OPNMSG
	CALL	MSGOUT

	IF USE_IDENT

	PUSHF			; Begin: (from Application Note 485)
	POP	AX
	MOV	CX,AX
	AND	AX,0FFFH
	PUSH	AX
	POPF
	PUSHF
	POP	AX
	AND	AX,0F000H
	CMP	AX,0F000H
	JNE	ID_286

	PUSH	SP
	POP	DX
	CMP	DX,SP
	JE	ID_UNK		; End:

	MOV	AX,0100H
	DB	0D5H,00H	; AAD 00H
	OR	AL,AL
	JNE	ID_V30
	;; 8086/80186
	MOV	AL,11H
	MOV	BX,IM86
	JMP	IDE
ID_V30:
	;; V30
	MOV	AL,14H
	MOV	BX,IMV30
	JMP	IDE
ID_286:
	OR	CX,0F000H	; Begin: (from Application Note 485)
	PUSH	CX
	POPF
	PUSHF
	POP	AX
	AND	AX,0F000H
	JNE	ID_386		; End
	;; 80286
	MOV	AL,31H
	MOV	BX,IM286
	JMP	IDE
ID_386:
	;; 80386
	MOV	AL,71H
	MOV	BX,IM386
	JMP	IDE
	;; Unknown
ID_UNK:
	XOR	AL,AL
	MOV	BX,IMUNK
IDE:
	MOV	[PSPEC],AL
	CALL	MSGOUT
	
	ENDIF
	
WSTART:
	MOV	BX,PROMPT
	CALL	MSGOUT
	CALL	GETLIN
	MOV	BX,INBUF
	CALL	SKIPSP
	CALL	UPPER
	AND	AL,AL
	JZ	WSTART

	CMP	AL,'D'
	JNE	M00
	JMP	DUMP
M00:	
	CMP	AL,'G'
	JNE	M01
	JMP	GO
M01:
	CMP	AL,'S'
	JNE	M02
	JMP	SETM

M02:	
	CMP	AL,'L'
	JNE	M03
	JMP	LOADH
M03:

	IF USE_REGCMD
	CMP	AL,'R'
	JNE	M05
	JMP	REG
M05:
	ENDIF

ERR:
	MOV	BX,ERRMSG
	CALL	MSGOUT
	JMP	WSTART

;;;
;;; DUMP memory
;;;

DUMP:
	INC	BX
	CALL	SKIPSP
	CALL	RDHEX
	OR	CL,CL
	JNZ	DP0
	;; No arg.
	CALL	SKIPSP
	OR	AL,AL
	JNZ	ERR

	MOV	DX,[DSADDR]
	ADD	DX,128
	MOV	[DEADDR],DX
	JMP	DPM

	;; 1st arg. found
DP0:
	MOV	AL,[BX]
	CMP	AL,':'
	JNZ	DP01
	MOV	[CURSEG],DX
	INC	BX
	CALL	RDHEX
	OR	CL,CL
	JZ	ERR
DP01:	
	MOV	[DSADDR],DX
	MOV	AL,[BX]
	CMP	AL,','
	JZ	DP1
	OR	AL,AL
	JNZ	ERR
	;; No 2nd arg.
	ADD	DX,128
	MOV	[DEADDR],DX
	JMP	DPM
DP1:
	INC	BX
	CALL	SKIPSP
	CALL	RDHEX
	CALL	SKIPSP
	OR	CL,CL
	JZ	ERR
	MOV	AL,[BX]
	OR	AL,AL
	JNZ	ERR
	INC	DX
	MOV	[DEADDR],DX
DPM:
	;; DUMP main
	MOV	ES,[CURSEG]
	MOV	SI,[DSADDR]
	AND	SI,0FFF0H
	XOR	AL,AL
	MOV	[DSTATE],AL
DPM0:
	CALL	DPL
	CALL	CONST
	OR	AL,AL
	JNZ	DPM1
	MOV	AL,[DSTATE]
	CMP	AL,2
	JC	DPM0
	MOV	BX,[DEADDR]
	MOV	[DSADDR],BX
	JMP	WSTART
DPM1:
	MOV	[DSADDR],SI
	CALL	CONIN
	JMP	WSTART

DPL:
	;; DUMP	line
	MOV	AX,[CURSEG]
	CALL	HEXOUT4
	MOV	AL,':'
	CALL	CONOUT
	MOV	AX,SI
	CALL	HEXOUT4
	MOV	BX,DSEP0
	CALL	MSGOUT
	MOV	DI,INBUF
	MOV	CX,16
DPL0:
	CALL	DPB
	LOOP	DPL0

	MOV	BX,DSEP1
	CALL	MSGOUT

	MOV	DI,INBUF
	MOV	CX,16
DPL1:
	MOV	AL,[DI]
	INC	DI
	CMP	AL,' '
	JC	DPL2
	CMP	AL,7FH
	JNC	DPL2
	CALL	CONOUT
	JMP	DPL3
DPL2:
	MOV	AL,'.'
	CALL	CONOUT
DPL3:
	LOOP	DPL1
	JMP	CRLF

DPB:
	;; DUMP byte
	MOV	AL,' '
	CALL	CONOUT
	MOV	AL,[DSTATE]
	OR	AL,AL
	JNZ	DPB2
	;; State 0
	CMP	SI,[DSADDR]
	JZ	DPB1
DPB0:
	;; Still 0 or 2
	MOV	AL,' '
	MOV	[DI],AL
	CALL	CONOUT
	MOV	AL,' '
	CALL	CONOUT
	INC	SI
	INC	DI
	RET
DPB1:
	;; Found start address
	MOV	AL,1
	MOV	[DSTATE],AL
DPB2:
	MOV	AL,[DSTATE]
	CMP	AL,1
	JNZ	DPB0		; state 2
	;; DUMP state 1
	MOV	AL,ES:[SI]
	MOV	[DI],AL
	CALL	HEXOUT2
	INC	SI
	INC	DI

	CMP	SI,[DEADDR]
	JNZ	DPB3
	;; Found end address
	MOV	AL,2
	MOV	[DSTATE],AL
DPB3:
	RET

;;;
;;; GO address
;;; 

GO:
	INC	BX
	CALL	SKIPSP
	CALL	RDHEX
	OR	CL,CL
	JZ	G1
	MOV	AL,[BX]
	CMP	AL,':'
	JNE	G0

	IF USE_REGCMD
	MOV	[REGCS],DX
	ELSE
	MOV	[CURSEG],DX
	ENDIF

	INC	BX
	CALL	RDHEX
	OR	CL,CL
	JZ	GE
G0:
	IF USE_REGCMD
	MOV	[REGIP],DX
	ELSE
	MOV	[GADDR],DX
	ENDIF
G1:
	MOV	AL,[BX]
	OR	AL,AL
	JNZ	GE

	IF USE_REGCMD

	MOV	SS,[REGSS]
	MOV	SP,[REGSP]
	
	MOV	AX,[REGF]
	PUSH	AX
	MOV	AX,[REGCS]
	PUSH	AX
	MOV	AX,[REGIP]
	PUSH	AX

	MOV	AX,[REGAX]
	MOV	BX,[REGBX]
	MOV	CX,[REGCX]
	MOV	DX,[REGDX]
	MOV	BP,[REGBP]
	MOV	SI,[REGSI]
	MOV	DI,[REGDI]
	MOV	ES,[REGES]
	MOV	DS,[REGDS]
	IRET

	ELSE

	PUSH	[CURSEG]
	PUSH	[GADDR]
	RETF

	ENDIF
GE:
	JMP	ERR

;;;
;;; SET memory
;;;

SETM:
	INC	BX
	CALL	SKIPSP
	CALL	RDHEX
	OR	CL,CL
	JZ	SM1
	MOV	AL,[BX]
	CMP	AL,':'
	JNE	SM0
	MOV	[CURSEG],DX
	INC	BX
	CALL	RDHEX
	OR	CL,CL
	JZ	GE
SM0:
	MOV	[SADDR],DX
	CALL	SKIPSP
	MOV	AL,[BX]
	OR	AL,AL
	JNZ	GE
SM1:
	MOV	AX,[CURSEG]
	MOV	ES,AX
	CALL	HEXOUT4
	MOV	AL,':'
	CALL	CONOUT
	MOV	SI,[SADDR]
	MOV	AX,SI
	CALL	HEXOUT4
	MOV	BX,DSEP1
	CALL	MSGOUT
	MOV	AL,ES:[SI]
	CALL	HEXOUT2
	MOV	AL,' '
	CALL	CONOUT
	CALL	GETLIN
	MOV	BX,INBUF
	CALL	SKIPSP
	MOV	AL,[BX]
	OR	AL,AL
	JNZ	SM2
	;; Empty (Increment address)
	INC	SI
	MOV	[SADDR],SI
	JMP	SM1
SM2:
	CMP	AL,'-'
	JNZ	SM3
	;; '-' (Decrement address)
	DEC	SI
	MOV	[SADDR],SI
	JMP	SM1
SM3:
	CMP	AL,'.'
	JNZ	SM4
	;; '.' (Quit)
	JMP	WSTART
SM4:
	CALL	RDHEX
	OR	CL,CL
	JZ	SME
	MOV	ES:[SI],DL
	INC	SI
	MOV	[SADDR],SI
	JMP	SM1
SME:
	JMP	ERR

;;;
;;; LOAD HEX file
;;;

LOADH:
	INC	BX
	CALL	SKIPSP
	CALL	RDHEX
	OR	CL,CL
	JZ	LH0
	MOV	AL,[BX]
	CMP	AL,':'
	JNE	LH1
	MOV	[CURSEG],DX
	INC	BX
	CALL	RDHEX
	OR	CL,CL
	JZ	LHE
	JMP	LH1
LH0:
	XOR	DX,DX
LH1:
	MOV	AL,[BX]
	OR	AL,AL
	JNZ	LHE
	MOV	SI,DX
	MOV	ES,[CURSEG]
LH2:	
	CALL	CONIN
	CALL	UPPER
	CMP	AL,'S'
	JE	LHS0
	CMP	AL,':'
	JE	LHI0
LH3:
	;; Skip to EOL
	CMP	AL,CR
	JE	LH2
	CMP	AL,LF
	JE	LH2
	CALL	CONIN
	JMP	LH3
LHE:
	JMP	ERR

LHI0:
	CALL	HEXIN
	MOV	CL,AL		; Checksum
	MOV	BL,AL		; Length

	CALL	HEXIN
	MOV	DH,AL		; Address H
	ADD	CL,AL		; Checksum

	CALL	HEXIN
	MOV	DL,AL		; Address L
	ADD	CL,AL		; Checksum

	MOV	DI,DX
	ADD	DI,SI		; Add offset

	CALL	HEXIN
	MOV	[RECTYP],AL	; Record Type
	ADD	CL,AL		; Checksum

	OR	BL,BL		; Check length
	JZ	LHI3
LHI1:
	CALL	HEXIN
	ADD	CL,AL		; Checksum

	MOV	BH,[RECTYP]
	OR	BH,BH
	JNZ	LHI2

	MOV	ES:[DI],AL
	INC	DI
LHI2:
	DEC	BL
	JNZ	LHI1
LHI3:
	CALL	HEXIN
	ADD	AL,CL
	JNZ	LHIE		; Checksum error
	MOV	AL,[RECTYP]
	OR	AL,AL
	JZ	LH3
	JMP	WSTART
LHIE:
	MOV	BX,IHEMSG
	CALL	MSGOUT
	JMP	WSTART

LHS0:
	CALL	CONIN
	MOV	[RECTYP],AL

	CALL	HEXIN
	MOV	BL,AL		; Length+3
	MOV	CL,AL		; Checksum

	CALL	HEXIN
	MOV	DH,AL		; Address H
	ADD	CL,AL		; Checksum
	
	CALL	HEXIN
	MOV	DL,AL		; Address L
	ADD	CL,AL		; Checksum

	MOV	DI,DX
	ADD	DI,SI		; Add offset

	SUB	BL,3
	JC	LHSE		; Length error
	JZ	LHS3
LHS1:
	CALL	HEXIN
	ADD	CL,AL		; Checksum

	MOV	BH,[RECTYP]
	CMP	BH,'1'
	JNZ	LHS2

	MOV	ES:[DI],AL
	INC	DI
LHS2:
	DEC	BL
	JNZ	LHS1
LHS3:
	CALL	HEXIN
	ADD	AL,CL
	CMP	AL,0FFH
	JNE	LHSE		; Checksum error

	MOV	AL,[RECTYP]
	CMP	AL,'9'
	JZ	LHSR
	JMP	LH3
LHSE:
	MOV	BX,SHEMSG
	CALL	MSGOUT
LHSR:
	JMP	WSTART

;;;
;;; Register
;;; 
	IF USE_REGCMD

REG:
	INC	BX
	CALL	SKIPSP
	CALL	UPPER
	OR	AL,AL
	JNE	RG0
	CALL	RDUMP
	JMP	WSTART
RG0:
	MOV	SI,RNTAB
RG1:
	CMP	AL,CS:[SI]
	JE	RG2		; Character match
	MOV	CL,CS:1[SI]
	OR	CL,CL
	JE	RGE
	ADD	SI,6
	JMP	RG1
RG2:
	MOV	AL,CS:1[SI]
	CMP	AL,0FH
	JNE	RG3
	;; Next table
	MOV	SI,CS:2[SI]
	INC	BX
	MOV	AL,[BX]
	CALL	UPPER
	JMP	RG1
RG3:	
	OR	AL,AL		; Found end mark
	JE	RGE

	MOV	CL,CS:1[SI]
	MOV	BX,CS:4[SI]
	CALL	MSGOUT
	MOV	AL,'='
	CALL	CONOUT
	MOV	BX,CS:2[SI]
	AND	CL,07H
	PUSH	BX
	PUSH	CX
	CMP	CL,1
	JNE	RG4
	;; 8 bit register
	MOV	AL,[BX]
	CALL	HEXOUT2
	JMP	RG5
RG4:
	;; 16 bit register
	MOV	AX,[BX]
	CALL	HEXOUT4
RG5:
	MOV	AL,' '
	CALL	CONOUT
	CALL	GETLIN
	MOV	BX,INBUF
	CALL	SKIPSP
	CALL	RDHEX
	OR	CL,CL
	JE	RGR
	POP	CX
	POP	BX
	CMP	CL,1
	JNE	RG6
	;; 8 bit register
	MOV	[BX],DL
	JMP	RG7
RG6:
	;; 16 bit register
	MOV	[BX],DX
RG7:
RGR:
	JMP	WSTART
RGE:
	JMP	ERR
	
RDUMP:
	MOV	SI,RDTAB
RD0:	
	MOV	BX,CS:[SI]
	OR	BX,BX
	JZ	RD1
	CALL	MSGOUT
	INC	SI
	INC	SI
	MOV	BX,CS:[SI]
	MOV	AX,[BX]
	CALL	HEXOUT4
	INC	SI
	INC	SI
	JMP	RD0
RD1:	
	JMP	CRLF
	
	ENDIF

;;;
;;; Other support routines
;;;

MSGOUT:
	MOV	AL,CS:[BX]
	AND	AL,AL
	JZ	MSGOE
	CALL	CONOUT
	INC	BX
	JMP	MSGOUT
MSGOE:
	RET

STROUT:
	MOV	AL,[BX]
	AND	AL,AL
	JZ	STROE
	CALL	CONOUT
	INC	BX
	JMP	STROUT
STROE:
	RET

HEXOUT4:
	PUSH	AX
	MOV	AL,AH
	CALL	HEXOUT2
	POP	AX
HEXOUT2:
	PUSH	AX
	SHR	AL,1
	SHR	AL,1
	SHR	AL,1
	SHR	AL,1
	CALL	HEXOUT1
	POP	AX
HEXOUT1:
	AND	AL,0FH
	ADD	AL,'0'
	CMP	AL,'9'+1
	JC	HO10
	ADD	AL,'A'-'9'-1
HO10:
	JMP	CONOUT

HEXIN:
	XOR	AL,AL
	CALL	HI0
	SHL	AL,1
	SHL	AL,1
	SHL	AL,1
	SHL	AL,1
HI0:
	MOV	CH,AL
	CALL	CONIN
	CALL	UPPER
	CMP	AL,'0'
	JC	HIR
	CMP	AL,'9'+1
	JC	HI1
	CMP	AL,'A'
	JC	HIR
	CMP	AL,'F'+1
	JNC	HIR
	SUB	AL,'A'-'9'-1
HI1:
	SUB	AL,'0'
	OR	AL,CH
HIR:
	RET

CRLF:
	MOV	AL,CR
	CALL	CONOUT
	MOV	AL,LF
	JMP	CONOUT

GETLIN:
	MOV	BX,INBUF
	XOR	CL,CL
GL0:
	CALL	CONIN
	CMP	AL,CR
	JZ	GLE
	CMP	AL,LF
	JZ	GLE
	CMP	AL,BS
	JZ	GLB
	CMP	AL,DEL
	JZ	GLB
	CMP	AL,' '
	JC	GL0
	CMP	AL,80H
	JNC	GL0
	CMP	CL,BUFLEN-1
	JNC	GL0		; Too long
	MOV	[BX],AL
	CALL	CONOUT
	INC	BX
	INC	CL
	JMP	GL0
GLB:
	AND	CL,CL
	JZ	GL0
	DEC	BX
	DEC	CL
	MOV	AL,BS
	CALL	CONOUT
	MOV	AL,' '
	CALL	CONOUT
	MOV	AL,BS
	CALL	CONOUT
	JMP	GL0
GLE:
	CALL	CRLF
	MOV	AL,00H
	MOV	[BX],AL
	RET
	
SKIPSP:
	MOV	AL,[BX]
	CMP	AL,' '
	JNE	SSR
	INC	BX
	JMP	SKIPSP
SSR:
	RET

UPPER:
	CMP	AL,'a'
	JC	UPR
	CMP	AL,'z'+1
	JNC	UPR
	ADD	AL,'A'-'a'
UPR:
	RET

RDHEX:
	XOR	CL,CL
	XOR	DX,DX
RH0:
	MOV	AL,[BX]
	CALL	UPPER
	CMP	AL,'0'
	JC	RHE
	CMP	AL,'9'+1
	JC	RH1
	CMP	AL,'A'
	JC	RHE
	CMP	AL,'F'+1
	JNC	RHE
	SUB	AL,'A'-'9'-1
RH1:
	SUB	AL,'0'
	SHL	DX,1
	SHL	DX,1
	SHL	DX,1
	SHL	DX,1
	OR	DL,AL
	INC	BX
	INC	CL
	JMP	RH0
RHE:
	RET

;;;
;;; Interrupt Handler
;;;

	IF USE_REGCMD

	;; Divide error (INT 00H)
INTDIV:
	PUSH	AX
	PUSH	DS
	MOV	AX,RAMSEG
	MOV	DS,AX
	MOV	[REGBX],BX
	MOV	[REGCX],CX
	MOV	BX,DIVMSG
	XOR	CX,CX		; IP adjustment
	JMP	INT0
	
	;; Single step (INT 01H)
INTSTP:
	PUSH	AX
	PUSH	DS
	MOV	AX,RAMSEG
	MOV	DS,AX
	MOV	[REGBX],BX
	MOV	[REGCX],CX
	MOV	BX,STPMSG
	XOR	CX,CX		; IP adjustment
	JMP	INT0
	
	;; Break (INT 03H)
INTBRK:
	PUSH	AX
	PUSH	DS
	MOV	AX,RAMSEG
	MOV	DS,AX
	MOV	[REGBX],BX
	MOV	[REGCX],CX
	MOV	BX,BRKMSG
	MOV	CX,1		; IP adjustment
	JMP	INT0
	
	;; Overflow (INT 04H)
INTOVF:
	PUSH	AX
	PUSH	DS
	MOV	AX,RAMSEG
	MOV	DS,AX
	MOV	[REGBX],BX
	MOV	[REGCX],CX
	MOV	BX,OVFMSG
	XOR	CX,CX		; IP adjustment
INT0:
	POP	AX
	MOV	[REGDS],AX
	POP	AX
	MOV	[REGAX],AX
	MOV	[REGDX],DX

	MOV	[REGBP],BP
	MOV	[REGSI],SI
	MOV	[REGDI],DI
	MOV	[REGES],ES

	POP	AX
	SUB	AX,CX
	MOV	[REGIP],AX
	POP	AX
	MOV	[REGCS],AX
	POP	AX
	MOV	[REGF],AX

	MOV	[REGSP],SP
	MOV	[REGSS],SS

	CALL	MSGOUT
	CALL	RDUMP
	JMP	WSTART

	ELSE

INTDIV:
INTSTP:
INTBRK:
INTOVF:
	IRET

	ENDIF

	;; Dummy
INTDMY:
	IRET
	
OPNMSG:
	DB	CR,LF,"Universal Monitor 8086",CR,LF,00H

PROMPT:
	DB	"] ",00H

IHEMSG:
	DB	"Error ihex",CR,LF,00H
SHEMSG:
	DB	"Error srec",CR,LF,00H
ERRMSG:
	DB	"Error",CR,LF,00H

DSEP0:
	DB	" :",00H
DSEP1:
	DB	" : ",00H
IHEXER:
        DB	":00000001FF",CR,LF,00H
SRECER:
        DB	"S9030000FC",CR,LF,00H

INIVEC:
	DW	INTDIV, ROMSEG	; 00H Divide error
	DW	INTSTP, ROMSEG	; 01H Single step
	DW	INTDMY, ROMSEG	; 02H NMI
	DW	INTBRK, ROMSEG	; 03H Breakpoint
	DW	INTOVF, ROMSEG	; 04H Overflow
INIVECE:

	IF USE_IDENT

IM86:	DB	"8086/8088",CR,LF,00H
IM186:	DB	"80186/80188",CR,LF,00H
IMV30:	DB	"V30/V20",CR,LF,00H
IM286:	DB	"80286",CR,LF,00H
IM386:	DB	"80386",CR,LF,00H
IMUNK:	DB	"Unknown",CR,LF,00H

	ENDIF
	
	IF USE_REGCMD

DIVMSG:	DB	"Divide error",CR,LF,00H
STPMSG:	DB	"Step",CR,LF,00H
NMIMSG:	DB	"NMI",CR,LF,00H
BRKMSG:	DB	"Break",CR,LF,00H
OVFMSG:	DB	"Overflow",CR,LF,00H

RDTAB:	DW	RDSAX, REGAX
	DW	RDSBX, REGBX
	DW	RDSCX, REGCX
	DW	RDSDX, REGDX
	DW	RDSF,  REGF
	DW	RDSCS, REGCS
	DW	RDSDS, REGDS
	DW	RDSSS, REGSS
	DW	RDSES, REGES
	DW	RDSSP, REGSP
	DW	RDSBP, REGBP
	DW	RDSSI, REGSI
	DW	RDSDI, REGDI
	DW	RDSIP, REGIP
	
	DW	0000H, 0000H

RDSAX:	DB	"AX=",00H
RDSBX:	DB	" BX=",00H
RDSCX:	DB	" CX=",00H
RDSDX:	DB	" DX=",00H
RDSF:	DB	" F=",00H
RDSCS:	DB	"  CS=",00H
RDSDS:	DB	" DS=",00H
RDSSS:	DB	" SS=",00H
RDSES:	DB	" ES=",00H
RDSSP:	DB	CR,LF,"SP=",00H
RDSBP:	DB	" BP=",00H
RDSSI:	DB	" SI=",00H
RDSDI:	DB	" DI=",00H
RDSIP:	DB	" IP=",00H

RNTAB:
	DB	'A',0FH		; "A?"
	DW	RNTABA,0
	DB	'B',0FH		; "B?"
	DW	RNTABB,0
	DB	'C',0FH		; "C?"
	DW	RNTABC,0
	DB	'D',0FH		; "D?"
	DW	RNTABD,0
	DB	'E',0FH		; "E?"
	DW	RNTABD,0
	DB	'F',2		; "F"
	DW	REGF,RNF
	DB	'I',0FH		; "I?"
	DW	RNTABI,0
	DB	'S',0FH		; "S?"
	DW	RNTABS,0

	DB	00H,0		; End mark
	DW	0,0
	
RNTABA:
	DB	'X',2		; "AX"
	DW	REGAX,RNAX
	DB	'H',1		; "AH"
	DW	REGAX+1,RNAH
	DB	'L',1		; "AL"
	DW	REGAX,RNAL

	DB	00H,0		; End mark
	DW	0,0

RNTABB:
	DB	'X',2		; "BX"
	DW	REGBX,RNBX
	DB	'H',1		; "BH"
	DW	REGBX+1,RNBH
	DB	'L',1		; "BL"
	DW	REGBX,RNBL
	DB	'P',2		; "BP"
	DW	REGBP,RNBP
	
	DB	00H,0		; End mark
	DW	0,0

RNTABC:
	DB	'X',2		; "CX"
	DW	REGCX,RNCX
	DB	'H',1		; "CH"
	DW	REGCX+1,RNCH
	DB	'L',1		; "CL"
	DW	REGCX,RNCL
	DB	'S',2		; "CS"
	DW	REGCS,RNCS
	
	DB	00H,0		; End mark
	DW	0,0
	
RNTABD:
	DB	'X',2		; "DX"
	DW	REGDX,RNDX
	DB	'H',1		; "DH"
	DW	REGDX+1,RNDH
	DB	'L',1		; "DL"
	DW	REGDX,RNDL
	DB	'I',2		; "DI"
	DW	REGDI,RNDI
	DB	'S',2		; "DS"
	DW	REGDS,RNDS
	
	DB	00H,0		; End mark
	DW	0,0

RNTABE:
	DB	'S',2		; "ES"
	DW	REGES,RNES
	
	DB	00H,0		; End mark
	DW	0,0
	
RNTABI:
	DB	'P',2		; "IP"
	DW	REGIP,RNIP
	
	DB	00H,0		; End mark
	DW	0,0
	
RNTABS:
	DB	'I',2		; "SI"
	DW	REGSI,RNSI
	DB	'P',2		; "SP"
	DW	REGSP,RNSP
	DB	'S',2		; "SS"
	DW	REGSS,RNSS
	
	DB	00H,0		; End mark
	DW	0,0
	
RNAX:	DB	"AX",00H
RNAH:	DB	"AH",00H
RNAL:	DB	"AL",00H
RNBX:	DB	"BX",00H
RNBH:	DB	"BH",00H
RNBL:	DB	"BL",00H
RNBP:	DB	"BP",00H
RNCX:	DB	"CX",00H
RNCH:	DB	"CH",00H
RNCL:	DB	"CL",00H
RNCS:	DB	"CS",00H
RNDX:	DB	"DX",00H
RNDH:	DB	"DH",00H
RNDL:	DB	"DL",00H
RNDI:	DB	"DI",00H
RNDS:	DB	"DS",00H
RNES:	DB	"ES",00H
RNF:	DB	"F",00H
RNIP:	DB	"IP",00H
RNSI:	DB	"SI",00H
RNSP:	DB	"SP",00H
RNSS:	DB	"SS",00H

	ENDIF

	IF USE_DEV_8251
	INCLUDE	"dev/dev_8251.asm"
	ENDIF

	IF USE_DEV_EMILY
	INCLUDE	"dev/dev_emily.asm"
	ENDIF

	;;
	;; Reset entry point
	;;
	
	ORG	( 0FFFF0H - ROMSEG * 16 )

	JMPF	ROMSEG:CSTART
	
;;;
;;; RAM area
;;;

	SEGMENT	DATA

	;;
	;; Work area
	;;

	ORG	WORK_B

INBUF:	DS	BUFLEN	; Line input buffer
CURSEG:	DS	2	; Current segment
DSADDR:	DS	2	; DUMP start address
DEADDR:	DS	2	; DUMP end address
DSTATE:	DS	1	; DUMP state
	ALIGN	2
GADDR:	DS	2	; GO address
SADDR:	DS	2	; SET address
HEXMOD:	DS	1	; HEX file mode
PSPEC:	DS	1	; Processor spec.

RECTYP:	DS	1	; Record type

	IF USE_REGCMD
	ALIGN	2
REG_B:	
REGAX:	DS	2
REGBX:	DS	2
REGCX:	DS	2
REGDX:	DS	2
REGF:	DS	2
REGSP:	DS	2		; Stack Pointer SP
REGBP:	DS	2		; Base Pointer BP
REGSI:	DS	2		; Source Index SI
REGDI:	DS	2		; Destination Index DI
REGIP:	DS	2		; Instruction Pointer IP
REGCS:	DS	2		; Code Segment CS
REGDS:	DS	2		; Data Segment DS
REGSS:	DS	2		; Stack Segment SS
REGES:	DS	2		; Extra Segment ES
REG_E:	
	ENDIF

	END
	
