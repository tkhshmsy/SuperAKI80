;;;
;;; Universal Monitor H8/300
;;;   Copyright (C) 2021  Haruo Asano
;;;

	INCLUDE	"config.inc"

	INCLUDE	"../common.inc"

	IF USE_ADVANCED
	MAXMODE	ON
	ELSE
	MAXMODE	OFF
	ENDIF

;;;
;;; ROM area
;;;

	;; Vector Area

	IF USE_ADVANCED

	;; Advanced Mode
	DC.L	CSTART

	ELSE

	;; Normal Mode
	DC.W	CSTART

	ENDIF


CSTART:
	ORC	#$80,CCR	; DI
	MOV	#STACK,ER7

	BSR	INIT

	MOV	#RAM_B,ER0
	MOV	ER0,@DSADDR
	MOV	ER0,GADDR
	MOV	ER0,SADDR
	MOV	#'I',R0L
	MOV	R0L,@HEXMOD

	;; Opening message
	MOV	#OPNMSG,ER4
	BSR	STROUT

WSTART:
	MOV	#PROMPT,ER4
	BSR	STROUT
	BSR	GETLIN
	MOV	#INBUF,ER4
	BSR	SKIPSP
	BSR	UPPER
	OR	R0L,R0L
	BEQ	WSTART

	CMP	#'D',R0L
	BEQ	DUMP
	CMP	#'G',R0L
	BEQ	GO
	CMP	#'S',R0L
	BEQ	SETM

	CMP	#'L',R0L
	BEQ	LOADH
	CMP	#'P',R0L
	BEQ	SAVEH

ERR:
	MOV	#ERRMSG,ER4
	BSR	STROUT
	BRA	WSTART

;;;
;;; Dump memory
;;;

DUMP:
	INC	ER4
	BSR	SKIPSP
	BSR	RDHEX		; 1st arg.
	OR	R2L,R2L
	BNE	DP0
	;; No arg.
	BSR	SKIPSP
	OR	R0L,R0L
	BNE	ERR
	MOV	@DSADDR,ER5
	MOV	ER5,ER6
	ADD	#128,ER6	; DEADDR
	BRA	DPM

	;; 1st arg. found
DP0:
	MOV	ER1,ER5		; DSADDR
	BSR	SKIPSP
	CMP	#',',R0L
	BEQ	DP1
	OR	R0L,R0L
	BNE	ERR
	;; No 2nd arg.
	MOV	ER5,ER6		; DEADDR
	ADD	#128,ER6
	BRA	DPM

DP1:
	INC	ER4
	BSR	SKIPSP
	BSR	RDHEX
	BSR	SKIPSP
	OR	R2L,R2L
	BEQ	ERR
	OR	R0L,R0L
	BNE	ERR
	INC	ER1
	MOV	ER1,ER6

	;; DUMP main
DPM:
	MOV	ER5,ER3
	AND	#$F0,R3L
	XOR	R2L,R2L		; DSTATE
DPM0:
	BSR	DPL
	BSR	CONST
	OR	R0L,R0L
	BNE	DPM1		; Abort
	CMP	#2,R2L		; DSTATE
	BCS	DPM0
	MOV	ER6,@DSADDR
	BRA	WSTART
DPM1:
	MOV	ER3,@DSADDR
	BSR	CONIN
	BRA	WSTART

	;; DUMP line
DPL:
	IF USE_ADVANCED
	MOV	ER3,ER0
	BSR	HEXOUT8
	ELSE
	MOV	ER3,R0
	BSR	HEXOUT4
	ENDIF
	MOV	#DSEP0,ER4
	BSR	STROUT
	MOV	#INBUF,ER4
	MOV	#16,R2H		; Count
DPL0:
	BSR	DPB
	DEC	R2H
	BNE	DPL0

	MOV	#DSEP1,ER4
	BSR	STROUT

	MOV	#INBUF,ER4
	MOV	#16,R2H		; Count
DPL1:
	MOV	@ER4+,R0L
	CMP	#' ',R0L
	BCS	DPL2
	CMP	#$7F,R0L
	BCC	DPL2
	BSR	CONOUT
	BRA	DPL3
DPL2:
	MOV	#'.',R0L
	BSR	CONOUT
DPL3:
	DEC	R2H
	BNE	DPL1
	BRA	CRLF

	;; DUMP byte
DPB:
	MOV	#' ',R0L
	BSR	CONOUT
	OR	R2L,R2L		; DSTATE
	BNE	DPB2
	;; Dump state 0
	CMP	ER5,ER3
	BEQ	DPB1
	;; Still 0 or 2
DPB0:
	MOV	#' ',R0L
	BSR	CONOUT
	BSR	CONOUT
	MOV	R0L,@ER4
	INC	ER4
	INC	ER3
	RTS
	;; Found start address
DPB1:
	MOV	#1,R2L		; DSTATE
DPB2:
	CMP	#1,R2L		; DSTATE
	BNE	DPB0
	;; Dump state 1
	MOV	@ER3+,R0L
	MOV	R0L,@ER4
	INC	ER4
	BSR	HEXOUT2
	CMP	ER6,ER3
	BEQ	DPB3
	RTS
	;; Found end address
DPB3:
	MOV	#2,R2L		; DSTATE
	RTS

;;;
;;; GO address
;;;

GO:
	INC	ER4
	BSR	SKIPSP
	BSR	RDHEX
	BSR	SKIPSP
	OR	R0L,R0L
	BNE	ERR
	OR	R2L,R2L
	BEQ	G0
	MOV	ER1,@GADDR
G0:
	MOV	@GADDR,ER0
	JMP	@ER0

;;;
;;; SET memory
;;;

SETM:
	INC	ER4
	BSR	SKIPSP
	BSR	RDHEX
	BSR	SKIPSP
	OR	R0L,R0L
	BNE	ERR
	MOV	ER1,ER3
	OR	R2L,R2L
	BNE	SM0
	MOV	@SADDR,ER3
SM0:
SM1:
	IF USE_ADVANCED
	MOV	ER3,ER0
	BSR	HEXOUT8
	ELSE
	MOV	ER3,R0
	BSR	HEXOUT4
	ENDIF
	MOV	#DSEP1,ER4
	BSR	STROUT
	MOV	@ER3,R0L
	BSR	HEXOUT2
	MOV	#' ',R0L
	BSR	CONOUT
	BSR	GETLIN
	MOV	#INBUF,ER4
	BSR	SKIPSP
	OR	R0L,R0L
	BNE	SM2
	;; Empty (Increment address)
	INC	ER3
	MOV	ER3,@SADDR
	BRA	SM1
SM2:
	CMP	#'-',R0L
	BNE	SM3
	;; '-' (Decrement address)
	DEC	ER3
	MOV	ER3,@SADDR
	BRA	SM1
SM3:
	CMP	#'.',R0L
	BNE	SM4
	;; '.' (Quit)
	MOV	ER3,@SADDR
	BRA	WSTART
SM4:
	BSR	RDHEX
	OR	R2L,R2L
	BEQ	ERR
	MOV	R1L,@ER3
	INC	ER3
	MOV	ER3,@SADDR
	BRA	SM1

;;;
;;; Load HEX file
;;;

LOADH:
	INC	ER4
	BSR	SKIPSP
	BSR	RDHEX
	BSR	SKIPSP
	OR	R0L,R0L
	BNE	ERR
LH0:
	BSR	CONIN
	BSR	UPPER
	CMP	#'S',R0L
	BEQ	LHS0
LH1:
	CMP	#':',R0L
	BEQ	LHI0
	;; Skip to EOL
LH2:
	CMP	#CR,R0L
	BEQ	LH0
	CMP	#LF,R0L
	BEQ	LH0
LH3:
	BSR	CONIN
	BRA	LH2

	;; Intel HEX
LHI0:
	BSR	HEXIN
	MOV	R0L,R2L		; Length
	MOV	R0L,R2H		; Checksum

	BSR	HEXIN
	XOR	ER4,ER4
	MOV	R0L,R4H		; Address H
	ADD	R0L,R2H		; Checksum

	BSR	HEXIN
	MOV	R0L,R4L		; Address L
	ADD	R0L,R2H		; Checksum

	;; Offset
	ADD	ER1,ER4

	BSR	HEXIN
	MOV	R0L,R5L		; RECTYP
	ADD	R0L,R2H		; Checksum
	CMP	#$00,R0L
	BEQ	LHI00
	CMP	#$01,R0L
	BEQ	LHI00
	BRA	LH3		; Skip unsupported record type
LHI00:

	OR	R2L,R2L
	BEQ	LHI3
LHI1:
	BSR	HEXIN
	ADD	R0L,R2H		; Checksum

	OR	R5L,R5L		; RECTYP
	BNE	LHI2

	MOV	R0L,@ER4
	INC	ER4
LHI2:
	DEC	R2L
	BNE	LHI1
LHI3:
	BSR	HEXIN
	ADD	R0L,R2H		; Checksum
	BNE	LHIE		; Checksum error

	OR	R5L,R5L		; RECTYP
	BEQ	LH3
	BRA	WSTART
LHIE:
	MOV	#IHEMSG,ER4
	BSR	STROUT
	BRA	WSTART

	;; Motorola S record
LHS0:
	BSR	CONIN
	XOR	R5L,R5L		; RECTYP
	MOV	#2,R5H		; 2 byte address
	CMP	#'1',R0L
	BEQ	LHS01
	CMP	#'9',R0L
	BEQ	LHS00
	MOV	#3,R5H		; 3 byte address
	CMP	#'2',R0L
	BEQ	LHS01
	CMP	#'8',R0L
	BEQ	LHS00
	MOV	#4,R5H		; 4 byte address
	CMP	#'3',R0L
	BEQ	LHS01
	CMP	#'7',R0L
	BEQ	LHS00
	BRA	LH3		; Skip unsupported record type
LHS00:
	MOV	#1,R5L		; RECTYP (end)
LHS01:

	BSR	HEXIN
	MOV	R0L,R2L		; Length + 2/3/4 + 1
	MOV	R0L,R2H		; Checksum

	XOR	ER4,ER4
LHS02:
	BSR	HEXIN
	SHLL	ER4
	SHLL	ER4
	SHLL	ER4
	SHLL	ER4
	SHLL	ER4
	SHLL	ER4
	SHLL	ER4
	SHLL	ER4
	MOV	R0L,R4L
	ADD	R0L,R2H		; Checksum

	DEC	R2L
	DEC	R5H
	BNE	LHS02

	;; Add offset
	ADD	ER1,ER4

	DEC	R2L
	BEQ	LHS3
LHS1:
	BSR	HEXIN
	ADD	R0L,R2H		; Checksum

	OR	R5L,R5L		; RECTYP
	BNE	LHS2

	MOV	R0L,@ER4
	INC	ER4
LHS2:
	DEC	R2L
	BNE	LHS1
LHS3:
	BSR	HEXIN
	ADD	R0L,R2H		; Checksum
	CMP	#$FF,R2H
	BNE	LHSE		; Checksum error

	OR	R5L,R5L		; RECTYP
	BEQ	LH3
	BRA	WSTART
LHSE:
	MOV	#SHEMSG,ER4
	BSR	STROUT
	BRA	WSTART

;;; Save HEX file

SAVEH:
	if USE_ADVANCED
	XOR	E2,E2		; 
	endif

	INC	ER4
	MOV	@ER4,R0L
	BSR	UPPER
	CMP	#'I',R0L
	BEQ	SH0
	CMP	#'S',R0L
	BEQ	SH0
	CMP	#'M',R0L
	BNE	SH1
SH0:
	MOV	R0L,@HEXMOD
	INC	ER4
SH1:
	BSR	SKIPSP
	BSR	RDHEX
	OR	R2L,R2L
	BEQ	ERR		; Start address missing
	MOV	ER1,ER5
	IF USE_ADVANCED
	AND	#$00FF,E5
	ENDIF			; ER5 = Start address
	BSR	SKIPSP
	CMP	#',',R0L
	BNE	ERR
	INC	ER4
	BSR	SKIPSP
	BSR	RDHEX
	OR	R2L,R2L
	BEQ	ERR		; End address missing
	MOV	ER1,ER3
	IF USE_ADVANCED
	AND	#$00FF,E3
	ENDIF			; ER3 = End address
	MOV	ER5,ER1		; Default output address = start address
	BSR	SKIPSP
	CMP	#',',R0L
	BNE	SH2
	INC	ER4
	BSR	SKIPSP
	BSR	RDHEX
	OR	R2L,R2L
	BEQ	ERR		; Output address empty
	if USE_ADVANCED
	AND	#$00FF,E1
	endif			; ER1 = Output address
	BSR	SKIPSP
SH2:	
	OR	R0L,R0L
	BNE	ERR

	SUB	ER5,ER3
	BCS	ERR		; Start address > End Address
	INC	ER3		; ER3 = Length
	MOV	ER3,ER6		; ER6 = Length

	XOR	R2L,R2L		; Ext  0:S1, 1:S2
	MOV	@HEXMOD,R0L
	CMP	#'M',R0L
	BNE	SH3
	INC	R2L
SH3:
	BSR	SHL
	OR	ER6,ER6
	BNE	SH3

	MOV	@HEXMOD,R1H
	CMP	#'I',R1H
	BNE	SH4
	;; End record for Intel HEX
	MOV	#IHEXER,ER4
	BSR	STROUT
	BRA	WSTART
SH4:
	;; End record for Motorola S record
	MOV	#SRECER,ER4
	BSR	STROUT
	BRA	WSTART

SHL:
	MOV	#16,ER3
	CMP	ER3,ER6
	BCC	SHL0
	MOV	ER6,ER3
SHL0:
	SUB	ER3,ER6

	OR	E1,E1
	BEQ	SHL1
	;; Address exceeded 16bit
	MOV	#1,R2L
	CMP	E2,E1
	BEQ	SHL1

	MOV	E1,E2

	MOV	@HEXMOD,R4L
	CMP	#'I',R4L
	BNE	SHL1

	;; Output 04 record
	MOV	#IHEX04,ER4
	BSR	STROUT
	MOV	#2+4,R2H	; Checksum

	MOV	E2,R0		; Address [23:16]
	ADD	R0L,R2H		; Checksum
	BSR	HEXOUT2

	MOV	R2H,R0L
	NEG	R0L		; Checksum
	BSR	HEXOUT2
	BSR	CRLF
SHL1:	
	
	MOV	@HEXMOD,R4L
	CMP	#'I',R4L
	BNE	SHLS

	;; Intel HEX
	MOV	#':',R0L
	BSR	CONOUT

	MOV	R3L,R0L		; Length
	BSR	HEXOUT2
	MOV	R3L,R2H		; Checksum

	MOV	R1H,R0L		; Address H
	ADD	R0L,R2H		; Checksum
	BSR	HEXOUT2

	MOV	R1L,R0L		; Address L
	ADD	R0L,R2H		; Checksum
	BSR	HEXOUT2

	XOR	R0L,R0L
	BSR	HEXOUT2

	ADD	ER3,ER1
SHLI0:
	MOV	@ER5+,R0L
	ADD	R0L,R2H		; Checksum
	BSR	HEXOUT2

	DEC	R3L
	BNE	SHLI0

	MOV	R2H,R0L
	NEG	R0L		; Checksum
	BSR	HEXOUT2
	BRA	CRLF

SHLS:
	;; Motorola S record
	MOV	#'S',R0L
	BSR	CONOUT

	MOV	#'1',R0L
	ADD	R2L,R0L
	BSR	CONOUT

	MOV	R3L,R0L
	ADD	#2+1,R0L	; DataLength + 2(addr) + 1(sum)
	ADD	R2L,R0L		; +1 if 24bit address
	MOV	R0L,R2H		; Checksum
	BSR	HEXOUT2

	OR	R2L,R2L
	BEQ	SHLS00
	MOV	E2,R0		; Address [23:16]
	ADD	R0L,R2H		; Checksum
	BSR	HEXOUT2
SHLS00:	
	MOV	R1H,R0L		; Address H
	ADD	R0L,R2H		; Checksum
	BSR	HEXOUT2

	MOV	R1L,R0L		; Address L
	ADD	R0L,R2H		; Checksum
	BSR	HEXOUT2

	ADD	ER3,ER1
SHLS0:
	MOV	@ER5+,R0L
	ADD	R0L,R2H		; Checksum
	BSR	HEXOUT2

	DEC	R3L
	BNE	SHLS0

	MOV	R2H,R0L
	NOT	R0L
	BSR	HEXOUT2
	BRA	CRLF

;;; Other support routines

STROUT:
	MOV.B	@ER4+,R0L
	BEQ	STROR
	BSR	CONOUT
	BRA	STROUT
STROR:
	RTS

	IF USE_ADVANCED
HEXOUT8:
	MOV	ER0,@-ER7
	MOV	E0,R0
	BSR	HEXOUT4
	MOV	@ER7+,ER0
	ENDIF
HEXOUT4:
	MOV	R0,@-ER7
	MOV	R0H,R0L
	BSR	HEXOUT2
	MOV	@ER7+,R0
HEXOUT2:
	MOV	R0,@-ER7
	SHLR	R0L
	SHLR	R0L
	SHLR	R0L
	SHLR	R0L
	BSR	HEXOUT1
	MOV	@ER7+,R0
HEXOUT1:
	AND	#$0F,R0L
	ADD	#'0',R0L
	CMP	#'9'+1,R0L
	BCS	CONOUT
	ADD	#'A'-'9'-1,R0L
	BRA	CONOUT

HEXIN:
	XOR	R0L,R0L
	BSR	HI0
	SHLL	R0L
	SHLL	R0L
	SHLL	R0L
	SHLL	R0L
HI0:
	MOV	R0L,R3L
	BSR	CONIN
	BSR	UPPER
	CMP	#'0',R0L
	BCS	HIR
	CMP	#'9'+1,R0L
	BCS	HI1
	CMP	#'A',R0L
	BCS	HIR
	CMP	#'F'+1,R0L
	BCC	HIR
	ADD	#-('A'-'9'-1),R0L
HI1:
	ADD	#-'0',R0L
	OR	R3L,R0L
HIR:
	RTS

CRLF:
	MOV	#CR,R0L
	BSR	CONOUT
	MOV	#LF,R0L
	BRA	CONOUT

GETLIN:
	MOV	#INBUF,ER4
	XOR	R1L,R1L
GL0:
	BSR	CONIN
	CMP	#CR,R0L
	BEQ	GLE
	CMP	#LF,R0L
	BEQ	GLE
	CMP	#BS,R0L
	BEQ	GLB
	CMP	#DEL,R0L
	BEQ	GLB
	CMP	#' ',R0L
	BCS	GL0
	CMP	#$80,R0L
	BCC	GL0
	CMP	#BUFLEN-1,R1L
	BCC	GL0		; Too long
	INC	R1L
	MOV	R0L,@ER4
	INC	ER4
	BSR	CONOUT
	BRA	GL0
GLB:
	OR	R1L,R1L
	BEQ	GL0
	DEC	ER4
	DEC	R1L
	MOV	#BS,R0L
	BSR	CONOUT
	MOV	#' ',R0L
	BSR	CONOUT
	MOV	#BS,R0L
	BSR	CONOUT
	BRA	GL0
GLE:
	BSR	CRLF
	MOV	#$00,R0L
	MOV	R0L,@ER4
	RTS
	
SKIPSP:
	MOV	@ER4+,R0L
	CMP	#' ',R0L
	BEQ	SKIPSP
	DEC	ER4
	RTS

UPPER:
	CMP	#'a',R0L
	BCS	UPR
	CMP	#'z'+1,R0L
	BCC	UPR
	ADD	#'A'-'a',R0L
UPR:
	RTS

RDHEX:
	XOR	R2L,R2L		; Count
	XOR	ER1,ER1		; Value
RH0:	
	MOV	@ER4,R0L
	BSR	UPPER
	CMP	#'0',R0L
	BCS	RHE
	CMP	#'9'+1,R0L
	BCS	RH1
	CMP	#'A',R0L
	BCS	RHE
	CMP	#'F'+1,R0L
	BCC	RHE
	ADD	#-('A'-'9'-1),R0L
RH1:
	ADD	#-'0',R0L
	SHLL	ER1
	SHLL	ER1
	SHLL	ER1
	SHLL	ER1
	OR	R0L,R1L
	INC	ER4
	INC	R2L
	BRA	RH0
RHE:
	RTS

;;;
;;; Data area
;;; 
	
OPNMSG:	DC.B	CR,LF,"Universal Monitor H8/300H",CR,LF,$00

PROMPT:	DC.B	"] ",$00

IHEMSG:	DC.B	"Error ihex",CR,LF,$00
SHEMSG:	DC.B	"Error srec",CR,LF,$00
ERRMSG:	DC.B	"Error",CR,LF,$00

DSEP0:	DC.B	" :",$00
DSEP1:	DC.B	" : ",$00
IHEXER:	DC.B	":00000001FF",CR,LF,$00
SRECER: DC.B	"S9030000FC",CR,LF,$00

	if USE_ADVANCED
IHEX04:	DC.B	":0200000400",$00
	endif

	ALIGN	2

	IF USE_DEV_SCI
	INCLUDE	"dev/dev_sci.asm"
	ENDIF

	IF USE_DEV_EMILY
	INCLUDE	"dev/dev_emily.asm"
	ENDIF

;;;
;;; RAM area
;;;

	ORG	WORK_B

INBUF:	DS.B	BUFLEN		; Line input buffer
	if USE_ADVANCED
DSADDR:	DS.L	1		; DUMP start address
GADDR:	DS.L	1		; GO address
SADDR:	DS.L	1		; SET address
	else
DSADDR:	DS.W	1		; DUMP start address
GADDR:	DS.W	1		; GO address
SADDR:	DS.W	1		; SET address
	endif

HEXMOD:	DS.B	1		; HEX file mode

	END
