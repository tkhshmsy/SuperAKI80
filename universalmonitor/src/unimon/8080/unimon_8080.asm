;;;
;;; Universal Monitor for 8080
;;;   Copyright (C) 2019,2020 Haruo Asano
;;;

	CPU	8080

TARGET	equ	"8080"

	INCLUDE	"config.inc"

	INCLUDE	"../common.inc"
	
;;;
;;; ROM area
;;;

	ORG	0000H
	DI
	JMP	CSTART

	ORG	0008H


	ORG	0010H
	JMP	CONOUT

	ORG	0018H
	JMP	STROUT

	ORG	0020H
	JMP	CONIN

	ORG	0028H
	JMP	CONST

	ORG	0030H
	JMP	RST6H

	ORG	0038H
	JMP	RST7H

	;;
	;; Entry point
	;;

	IFDEF ENTRY
	
	ORG	ENTRY+0		; Cold start
E_CSTART:
	JMP	CSTART

	ORG	ENTRY+8		; Warm start
E_WSTART:
	JMP	WSTART

	ORG	ENTRY+16	; Console output
E_CONOUT:
	JMP	CONOUT

	ORG	ENTRY+24	; (Console) String output
E_STROUT:
	JMP	STROUT

	ORG	ENTRY+32	; Console input
E_CONIN:
	JMP	CONIN

	ORG	ENTRY+40	; Console status
E_CONST:
	JMP	CONST

	ORG	0100H

	ENDIF			; ENTRY

	;;
	;;
	;;
	
CSTART:
	LXI	SP,STACK

	CALL	INIT

	LXI	H,8000H
	SHLD	DSADDR
	SHLD	SADDR
	SHLD	GADDR
	IF NO_SREC == 0
	MVI	A,'I'
	STA	HEXMOD
	ENDIF
	XRA	A
	STA	PSPEC

	IF USE_REGCMD

	;; Initialize register save area
	LXI	H,REG_B
	MVI	C,(REG_E-REG_B)
	XRA	A
INIR0:
	MOV	M,A
	INX	H
	DCR	C
	JNZ	INIR0

	LXI	H,STACK
	SHLD	REGSP
	LXI	H,8000H
	SHLD	REGPC
	
	ENDIF
	
	;; Opening message
	LXI	H,OPNMSG
	CALL	STROUT

	;; CPU identification
	IF USE_IDENT
	MVI	A,7FH
	INR	A
	JPE	ID_Z80		; Z80, HD64180, Z280
	PUSH	PSW
	POP	B
	MOV	A,C
	ANI	08H
	JNZ	ID_NEC		; NEC uPD8080A
	LXI	H,0FFFFH
	INX	H
	PUSH	PSW
	POP	B
	MOV	A,C
	ANI	20H
	JNZ	ID_85		; i8085
	;; i8080 (uPD8080AF)
	LXI	H,IM8080
	XRA	A
	JMP	IDE
	;; uPD8080A
ID_NEC:
	LXI	H,IMNEC
	MVI	A,01H
	JMP	IDE
	;; i8085
ID_85:
	LXI	H,IM8085
	MVI	A,02H
	JMP	IDE
	;; Z80
ID_Z80:
	LXI	H,IMZ80
	MVI	A,10H
IDE:
	STA	PSPEC
	CALL	STROUT
	ENDIF

WSTART:
	LXI	H,PROMPT
	CALL	STROUT
	CALL	GETLIN
	LXI	H,INBUF
	CALL	SKIPSP
	CALL	UPPER
	ORA	A
	JZ	WSTART
	CPI	'D'
	JZ	DUMP
	CPI	'G'
	JZ	GO
	CPI	'S'
	JZ	SETM

	IF USE_HEXCMD
	CPI	'L'
	JZ	LOADH
	CPI	'P'
	JZ	SAVEH
	ENDIF			; USE_HEXCMD

	IF USE_IOCMD
	CPI	'I'
	JZ	PIN
	CPI	'O'
	JZ	POUT
	ENDIF			; USE_IOCMD

	IF USE_REGCMD
	CPI	'R'
	JZ	REG
	ENDIF
	
ERR:
	LXI	H,ERRMSG
	CALL	STROUT
	JMP	WSTART

;;;
;;; Dump memory
;;; 

DUMP:
	INX	H
	CALL	SKIPSP
	CALL	RDHEX		; 1st arg.
	MOV	A,C
	ORA	A
	JNZ	DP0
	; No arg.
	CALL	SKIPSP
	MOV	A,M
	ORA	A
	JNZ	ERR
	LHLD	DSADDR
	LXI	B,128
	DAD	B
	SHLD	DEADDR
	JMP	DPM

DP0:	; 1st arg. found
	XCHG
	SHLD	DSADDR
	XCHG
	CALL	SKIPSP
	MOV	A,M
	CPI	','
	JZ	DP1
	ORA	A
	JNZ	ERR
	; No 2nd arg.
	LXI	H,128
	DAD	D
	SHLD	DEADDR
	JMP	DPM
DP1:
	INX	H
	CALL	SKIPSP
	CALL	RDHEX
	CALL	SKIPSP
	MOV	A,C
	ORA	A
	JZ	ERR
	MOV	A,M
	ORA	A
	JNZ	ERR
	INX	D
	XCHG
	SHLD	DEADDR
	XCHG			; Might not needed
DPM:
	; DUMP main
	LHLD	DSADDR
	MVI	A,0F0H
	ANA	L
	MOV	L,A
	XRA	A
	STA	DSTATE
DPM0:
	PUSH	H
	CALL	DPL
	POP	H
	LXI	B,16
	DAD	B
	CALL	CONST
	JNZ	DPM1
	LDA	DSTATE
	CPI	2
	JC	DPM0
	LHLD	DEADDR
	SHLD	DSADDR
	JMP	WSTART
DPM1:
	CALL	CONIN
	SHLD	DSADDR
	JMP	WSTART

DPL:	; Dump line
	CALL	HEXOUT4
	PUSH	H
	LXI	H,DSEP0
	CALL	STROUT
	LXI	H,INBUF
	SHLD	ASCPT
	POP	H
	MVI	B,16
DPL0:
	CALL	DPB
	DCR	B
	JNZ	DPL0

	LXI	H,DSEP1
	CALL	STROUT

	; Print ASCII area
	LXI	H,INBUF
	MVI	B,16
DPL1:
	MOV	A,M
	INX	H
	CPI	' '
	JC	DPL2
	CPI	7FH
	JNC	DPL2
	CALL	CONOUT
	JMP	DPL3
DPL2:
	MVI	A,'.'
	CALL	CONOUT
DPL3:
	DCR	B
	JNZ	DPL1
	JMP	CRLF

DPB:	; Dump byte
	MVI	A,' '
	CALL	CONOUT
	LDA	DSTATE
	ORA	A
	JNZ	DPB2
	; Dump state 0
	LDA	DSADDR		; Low byte
	CMP	L
	JNZ	DPB0
	LDA	DSADDR+1	; High byte
	CMP	H
	JZ	DPB1
DPB0:	; Still 0 or 2
	MVI	A,' '
	CALL	CONOUT
	CALL	CONOUT
	PUSH	H
	LHLD	ASCPT
	MOV	M,A
	INX	H
	SHLD	ASCPT
	POP	H
	INX	H
	RET
DPB1:	; Found start address
	MVI	A,1
	STA	DSTATE
DPB2:
	LDA	DSTATE
	CPI	1
	JNZ	DPB0
	; Dump state 1
	MOV	A,M
	PUSH	H
	LHLD	ASCPT
	MOV	M,A
	INX	H
	SHLD	ASCPT
	POP	H
	CALL	HEXOUT2
	INX	H
	LDA	DEADDR	; Low byte
	CMP	L
	RNZ
	LDA	DEADDR+1	; High byte
	CMP	H
	RNZ
	; Found end address
	MVI	A,2
	STA	DSTATE
	RET

;;;
;;; GO address
;;;

GO:
	INX	H
	CALL	SKIPSP
	CALL	RDHEX
	MOV	A,M
	ORA	A
	JNZ	ERR
	MOV	A,C
	ORA	A
	JZ	G0
	MOV	H,D
	MOV	L,E

	IF USE_REGCMD

	SHLD	REGPC
G0:
	LHLD	REGSP
	SPHL
	LHLD	REGPC
	PUSH	H
	LDA	REGF
	MOV	C,A
	LDA	REGA
	MOV	B,A
	PUSH	B		; Reg. A & F
	LXI	H,REGBC
	MOV	C,M
	INX	H
	MOV	B,M
	INX	H
	MOV	E,M
	INX	H
	MOV	D,M
	LHLD	REGHL
	POP	PSW
	RET
	
	ELSE

	SHLD	GADDR
G0:
	LHLD	GADDR
	PCHL

	ENDIF

;;;
;;; SET memory
;;;
	
SETM:
	INX	H
	CALL	SKIPSP
	CALL	RDHEX
	CALL	SKIPSP
	MOV	A,M
	ORA	A
	JNZ	ERR
	XCHG		; EX DE,HL
	MOV	A,C
	ORA	A
	JNZ	SM0
	LHLD	SADDR
SM0:

SM1:
	CALL	HEXOUT4
	PUSH	H
	LXI	H,DSEP1
	CALL	STROUT
	POP	H
	MOV	A,M
	PUSH	H
	CALL	HEXOUT2
	MVI	A,' '
	CALL	CONOUT
	CALL	GETLIN
	LXI	H,INBUF
	CALL	SKIPSP
	MOV	A,M
	ORA	A
	JNZ	SM2
	; Empty  (Increment address)
	POP	H
	INX	H
	SHLD	SADDR
	JMP	SM1
SM2:
	CPI	'-'
	JNZ	SM3
	; '-'  (Decrement address)
	POP	H
	DCX	H
	SHLD	SADDR
	JMP	SM1
SM3:
	CPI	'.'
	JNZ	SM4
	POP	H
	SHLD	SADDR
	JMP	WSTART
SM4:
	CALL	RDHEX
	MOV	A,C
	ORA	A
	POP	H
	JZ	ERR
	MOV	M,E
	INX	H
	SHLD	SADDR
	JMP	SM1

;;; LOAD HEX file

	IF USE_HEXCMD

LOADH:
	INX	H
	CALL	SKIPSP
	CALL	RDHEX
	CALL	SKIPSP
	MOV	A,M
	ORA	A
	JNZ	ERR

	MOV	A,C
	ORA	A
	JNZ	LH0

	LXI	D,0		; Offset
LH0:
	CALL	CONIN
	CALL	UPPER
	IF NO_SREC == 0
	CPI	'S'
	JZ	LHS0
	ENDIF
LH1:
	CPI	':'
	JZ	LHI0
LH2:
	;; Skip to EOL
	CPI	CR
	JZ	LH0
	CPI	LF
	JZ	LH0
LH3:
	CALL	CONIN
	JMP	LH2

LHI0:
	CALL	HEXIN
	MOV	C,A		; Checksum
	MOV	B,A		; Length

	CALL	HEXIN
	MOV	H,A		; Address H
	ADD	C
	MOV	C,A		; Checksum

	CALL	HEXIN
	MOV	L,A		; Address L
	ADD	C
	MOV	C,A		; Checksum

	;; Add offset
	DAD	D

	CALL	HEXIN
	STA	RECTYP		; Record Type
	ADD	C
	MOV	C,A		; Checksum

	MOV	A,B
	ORA	A
	JZ	LHI3
LHI1:
	CALL	HEXIN
	PUSH	PSW
	ADD	C
	MOV	C,A		; Checksum

	LDA	RECTYP
	ORA	A
	JNZ	LHI20

	POP	PSW
	MOV	M,A
	INX	H
	JMP	LHI2
LHI20:
	POP	PSW		; Drop
LHI2:
	DCR	B
	JNZ	LHI1
LHI3:
	CALL	HEXIN
	ADD	C
	JNZ	LHIE		; Checksum error
	LDA	RECTYP
	ORA	A
	JZ	LH3
	JMP	WSTART
LHIE:
	LXI	H,IHEMSG
	CALL	STROUT
	JMP	WSTART

	IF NO_SREC == 0
LHS0:
	CALL	CONIN
	STA	RECTYP		; Record type

	CALL	HEXIN
	MOV	B,A		; Length+3
	MOV	C,A		; Checksum

	CALL	HEXIN
	MOV	H,A		; Address H
	ADD	C
	MOV	C,A		; Checksum

	CALL	HEXIN
	MOV	L,A		; Address L
	ADD	C
	MOV	C,A		; Checksum

	DAD	D

	DCR	B
	DCR	B
	DCR	B
	JZ	LHS3
LHS1:
	CALL	HEXIN
	PUSH	PSW
	ADD	C
	MOV	C,A		; Checksum

	LDA	RECTYP
	CPI	'1'
	JNZ	LHS2

	POP	PSW
	MOV	M,A
	INX	H
	JMP	LHS20
LHS2:
	POP	PSW		; Drop
LHS20:
	DCR	B
	JNZ	LHS1
LHS3:
	CALL	HEXIN
	ADD	C
	CPI	0FFH
	JNZ	LHSE		; Checksum error

	LDA	RECTYP
	CPI	'7'
	JZ	WSTART
	CPI	'8'
	JZ	WSTART
	CPI	'9'
	JZ	WSTART
	JMP	LH3
LHSE:
	LXI	H,SHEMSG
	CALL	STROUT
	JMP	WSTART

	ENDIF			; NO_SREC

	ENDIF			; USE_HEXCMD


;;; SAVE HEX file

	IF USE_HEXCMD

SAVEH:
	INX	H
	
	IF NO_SREC == 0
	MOV	A,M
	CALL	UPPER
	CPI	'I'
	JZ	SH0
	CPI	'S'
	JNZ	SH1
SH0:
	INX	H
	STA	HEXMOD
SH1:
	ENDIF			; NO_SREC

	CALL	SKIPSP
	CALL	RDHEX
	MOV	A,C
	ORA	A
	JZ	SHE
	XCHG
	SHLD	ASCPT		; (ASCPT) = Start address
	XCHG
	CALL	SKIPSP
	MOV	A,M
	CPI	','
	JNZ	SHE
	INX	H
	CALL	SKIPSP
	CALL	RDHEX
	MOV	A,C
	ORA	A
	JZ	SHE
	CALL	SKIPSP
	MOV	A,M
	ORA	A
	JZ	SH2
SHE:
	JMP	ERR

SH2:
	LHLD	ASCPT
	INX	D
	MOV	A,E
	SUB	L
	STA	COUNT
	MOV	A,D
	SBB	H
	STA	COUNT+1		; (COUNT) = Length
SH3:
	CALL	SHL
	LDA	COUNT
	MOV	B,A
	LDA	COUNT+1
	ORA	B
	JNZ	SH3

	IF NO_SREC == 0
	LDA	HEXMOD
	CPI	'I'
	JZ	SH4
	;; End record for Motorola S record
	LXI	H,SRECER
	CALL	STROUT
	JMP	WSTART
SH4:
	ENDIF
	;; End record for Intel HEX
	LXI	H,IHEXER
	CALL	STROUT
	JMP	WSTART

SHL:
	MVI	B,16
	LDA	COUNT+1		; Length H
	ORA	A
	JNZ	SHL0
	LDA	COUNT		; Length L
	CMP	B
	JNC	SHL0
	MOV	B,A
SHL0:
	LDA	COUNT
	SUB	B
	STA	COUNT
	LDA	COUNT+1
	SBI	0
	STA	COUNT+1

	IF NO_SREC == 0
	LDA	HEXMOD
	CPI	'I'
	JNZ	SHLS
	ENDIF

	;; Intel HEX
	MVI	A,':'
	CALL	CONOUT

	MOV	A,B
	CALL	HEXOUT2		; Length
	MOV	A,B
	MOV	C,A		; Checksum

	MOV	A,H
	CALL	HEXOUT2		; Address H
	MOV	A,H
	ADD	C
	MOV	C,A

	MOV	A,L
	CALL	HEXOUT2		; Address L
	MOV	A,L
	ADD	C
	MOV	C,A

	XRA	A
	CALL	HEXOUT2
SHLI0:
	MOV	A,M
	PUSH	PSW
	CALL	HEXOUT2
	POP	PSW
	ADD	C
	MOV	C,A

	INX	H
	DCR	B
	JNZ	SHLI0

	MOV	A,C
	CMA
	INR	A
	CALL	HEXOUT2
	JMP	CRLF

	IF NO_SREC == 0
SHLS:
	;; Motorola S record
	MVI	A,'S'
	CALL	CONOUT
	MVI	A,'1'
	CALL	CONOUT

	MOV	A,B
	ADI	2+1		; DataLength + Addr(2) + Sum(1)
	MOV	C,A
	CALL	HEXOUT2

	MOV	A,H
	CALL	HEXOUT2		; Address H
	MOV	A,H
	ADD	C
	MOV	C,A

	MOV	A,L
	CALL	HEXOUT2		; Address L
	MOV	A,L
	ADD	C
	MOV	C,A
SHLS0:
	MOV	A,M
	PUSH	PSW
	CALL	HEXOUT2		; Data
	POP	PSW
	ADD	C
	MOV	C,A

	INX	H
	DCR	B
	JNZ	SHLS0

	MOV	A,C
	CMA
	CALL	HEXOUT2		; Checksum
	JMP	CRLF

	ENDIF			; NO_SREC

	ENDIF			; USE_HEXCMD

;;; Port in

	IF USE_IOCMD

PIN:
	INX	H
	CALL	SKIPSP
	CALL	RDHEX
	MOV	A,C
	ORA	A
	JZ	ERR		; Port addr. missing
	CALL	SKIPSP
	MOV	A,M
	ORA	A
	JNZ	ERR

	LXI	H,INBUF
	MVI	M,0DBH		; OPCODE of IN
	INX	H
	MOV	M,E		; Port address
	INX	H
	MVI	M,0C9H		; OPCODE of RET
	CALL	INBUF
	CALL	HEXOUT2
	CALL	CRLF
	JMP	WSTART

	ENDIF			; USE_IOCMD


;;; Port out

	IF USE_IOCMD

POUT:
	INX	H
	CALL	SKIPSP
	CALL	RDHEX
	MOV	A,C
	ORA	A
	JZ	ERR		; Port addr. missing
	MOV	B,E		; Port address
	CALL	SKIPSP
	MOV	A,M
	CPI	','
	JNZ	ERR
	INX	H
	CALL	SKIPSP
	CALL	RDHEX
	MOV	A,C
	ORA	A
	JZ	ERR		; Data missing
	CALL	SKIPSP
	MOV	A,M
	ORA	A
	JNZ	ERR

	LXI	H,INBUF
	MVI	M,0D3H		; OPCODE of OUT
	INX	H
	MOV	M,B		; Port address
	INX	H
	MVI	M,0C9H		; OPCODE of RET
	MOV	A,E		; Data
	CALL	INBUF
	JMP	WSTART

	ENDIF			; USE_IOCMD

;;; Register

	IF USE_REGCMD

REG:
	INX	H
	CALL	SKIPSP
	CALL	UPPER
	ORA	A
	JNZ	RG0
	CALL	RDUMP
	JMP	WSTART
RG0:
	XCHG
	LXI	H,RNTAB
RG1:
	CMP	M
	JZ	RG2		; Character match
	MOV	C,A
	INX	H
	MOV	A,M
	ORA	A
	JZ	RGE
	MOV	A,C
	LXI	B,5
	DAD	B
	JMP	RG1
RG2:
	INX	H
	MOV	A,M
	CPI	0FH
	JNZ	RG3
	;; Next table
	INX	H
	MOV	C,M
	INX	H
	MOV	H,M
	MOV	L,C
	INX	D
	LDAX	D
	CALL	UPPER
	JMP	RG1
RG3:
	ORA	A
	JZ	RGE		; Found end mark

	MOV	C,M
	INX	H
	MOV	E,M
	INX	H
	MOV	D,M
	PUSH	D		; Reg storage address
	INX	H
	MOV	A,M
	INX	H
	MOV	H,M
	MOV	L,A
	CALL	STROUT
	MVI	A,'='
	CALL	CONOUT

	MOV	A,C
	ANI	07H
	CPI	1
	JNZ	RG4
	;; 8 bit register
	POP	H
	MOV	A,M
	PUSH	H
	CALL	HEXOUT2
	JMP	RG5
RG4:
	;; 16 bit register
	POP	H
	PUSH	H
	MOV	E,M
	INX	H
	MOV	D,M
	XCHG
	CALL	HEXOUT4
RG5:
	MVI	A,' '
	CALL	CONOUT
	PUSH	B		; C: reg size
	CALL	GETLIN
	LXI	H,INBUF
	CALL	SKIPSP
	CALL	RDHEX
	MOV	A,C
	ORA	A
	JZ	RGR
	POP	B
	MOV	A,C
	CPI	1
	JNZ	RG6
	;; 8 bit register
	POP	H
	MOV	M,E
	JMP	RG7
RG6:
	;; 16 bit register
	POP	H
	MOV	M,E
	INX	H
	MOV	M,D
RG7:
RGR:
	JMP	WSTART
RGE:
	JMP	ERR

RDUMP:
	LXI	H,RDTAB
RD0:	
	MOV	E,M
	INX	H
	MOV	D,M
	INX	H
	MOV	A,D
	ORA	E
	JZ	CRLF
	XCHG
	CALL	STROUT
	XCHG
	MOV	E,M
	INX	H
	MOV	D,M
	INX	H
	MOV	A,M
	INX	H
	XCHG
	CPI	1
	JNZ	RD1
	;; 1 byte
	MOV	A,M
	CALL	HEXOUT2
	XCHG
	JMP	RD0
RD1:	
	;; 2 byte
	INX	H
	MOV	A,M
	CALL	HEXOUT2
	DCX	H
	MOV	A,M
	CALL	HEXOUT2
	XCHG
	JMP	RD0

	ENDIF

;;;
;;; Other support routines
;;;

STROUT:
	MOV	A,M
	ANA	A
	RZ
	CALL	CONOUT
	INX	H
	JMP	STROUT

HEXOUT4:
	MOV	A,H
	CALL	HEXOUT2
	MOV	A,L
HEXOUT2:
	PUSH	PSW
	RAR
	RAR
	RAR
	RAR
	CALL	HEXOUT1
	POP	PSW
HEXOUT1:
	ANI	0FH
	ADI	'0'
	CPI	'9'+1
	JC	CONOUT
	ADI	'A'-'9'-1
	JMP	CONOUT

	IF USE_HEXCMD

HEXIN:
	XRA	A
	CALL	HI0
	RLC
	RLC
	RLC
	RLC
HI0:
	PUSH	B
	MOV	C,A
	CALL	CONIN
	CALL	UPPER
	CPI	'0'
	JC	HIR
	CPI	'9'+1
	JC	HI1
	CPI	'A'
	JC	HIR
	CPI	'F'+1
	JNC	HIR
	SUI	'A'-'9'-1
HI1:
	SUI	'0'
	ORA	C
HIR:
	POP	B
	RET

	ENDIF			; USE_HEXCMD

CRLF:
	MVI	A,CR
	CALL	CONOUT
	MVI	A,LF
	JMP	CONOUT

GETLIN:
	LXI	H,INBUF
	MVI	B,0
GL0:
	CALL	CONIN
	CPI	CR
	JZ	GLE
	CPI	LF
	JZ	GLE
	CPI	BS
	JZ	GLB
	CPI	DEL
	JZ	GLB
	CPI	' '
	JC	GL0
	CPI	80H
	JNC	GL0
	MOV	C,A
	MOV	A,B
	CPI	BUFLEN-1
	JNC	GL0		; Too long
	INR	B
	MOV	A,C
	CALL	CONOUT
	MOV	M,A
	INX	H
	JMP	GL0
GLB:
	MOV	A,B
	ANA	A
	JZ	GL0
	DCR	B
	DCX	H
	MVI	A,08H
	CALL	CONOUT
	MVI	A,' '
	CALL	CONOUT
	MVI	A,08H
	CALL	CONOUT
	JMP	GL0
GLE:
	CALL	CRLF
	MVI	M,00H
	RET

SKIPSP:
	MOV	A,M
	CPI	' '
	RNZ
	INX	H
	JMP	SKIPSP

UPPER:
	CPI	'a'
	RC
	CPI	'z'+1
	RNC
	ADI	'A'-'a'
	RET

RDHEX:
	MVI	C,0
	LXI	D,0
RH0:
	MOV	A,M
	CALL	UPPER
	CPI	'0'
	JC	RHE
	CPI	'9'+1
	JC	RH1
	CPI	'A'
	JC	RHE
	CPI	'F'+1
	JNC	RHE
	SUI	'A'-'9'-1
RH1:
	SUI	'0'
	RAL
	RAL
	RAL
	RAL
	RAL
	PUSH	PSW
	MOV	A,E
	RAL
	MOV	E,A
	MOV	A,D
	RAL
	MOV	D,A
	POP	PSW
	RAL
	PUSH	PSW
	MOV	A,E
	RAL
	MOV	E,A
	MOV	A,D
	RAL
	MOV	D,A
	POP	PSW
	RAL
	PUSH	PSW
	MOV	A,E
	RAL
	MOV	E,A
	MOV	A,D
	RAL
	MOV	D,A
	POP	PSW
	RAL
	MOV	A,E
	RAL
	MOV	E,A
	MOV	A,D
	RAL
	MOV	D,A
	INX	H
	INR	C
	JMP	RH0
RHE:
	RET

;;;
;;; RST 6 Handler
;;;

RST6H:
	IF USE_NEWAPI

	PUSH	H
	PUSH	B
	LXI	H,APITBL
	MVI	B,0
	DAD	B
	DAD	B
	MOV	B,M
	INX	H
	MOV	H,M
	MOV	L,B
	POP	B
	XTHL			; Restore HL, jump address on stack top
	RET
	
APITBL:
	DW	API00		; 00: CSTART
	DW	API01		; 01: WSTART
	DW	CONOUT		; 02: CONOUT
	DW	STROUT		; 03: STROUT
	DW	CONIN		; 04: CONIN
	DW	CONST		; 05: CONST
	DW	API06		; 06: PSPEC

	;; CSTART
API00:
	POP	H		; Drop return address
	DI
	JP	CSTART

	;; WSTART
API01:	
	POP	H		; Drop return address
	JP	WSTART

	;; PSPEC
API06:
	LDA	PSPEC
	RET

	ELSE			; USE_NEWAPI

	RET

	ENDIF			; USE_NEWAPI

;;;
;;; RST 7 Handler
;;;

RST7H:
	IF USE_REGCMD

	PUSH	PSW
	SHLD	REGHL
	LXI	H,REGBC
	MOV	M,C
	INX	H
	MOV	M,B
	INX	H
	MOV	M,E
	INX	H
	MOV	M,D
	POP	B
	MOV	A,B
	STA	REGA
	MOV	A,C
	STA	REGF
	POP	H
	DCX	H
	SHLD	REGPC
	LXI	H,0000H
	DAD	SP
	SHLD	REGSP

	LXI	H,RST7MSG
	CALL	STROUT
	CALL	RDUMP
	JMP	WSTART

	ELSE

	RET
	
	ENDIF

DMYINT:
	EI
	RET

OPNMSG:
	DB	CR,LF,"Universal Monitor 8080",CR,LF,00H

PROMPT:
	DB	"] ",00H

ERRMSG:
	DB	"Error",CR,LF,00H

DSEP0:
	DB	" :",00H
DSEP1:
	DB	" : ",00H

	IF USE_HEXCMD
IHEMSG:
	DB	"Error ihex",CR,LF,00H
IHEXER:
        DB	":00000001FF",CR,LF,00H
	IF NO_SREC == 0
SHEMSG:
	DB	"Error srec",CR,LF,00H
SRECER:
        DB	"S9030000FC",CR,LF,00H
	ENDIF
	ENDIF

	IF USE_IDENT
IM8080:
	DB	"i8080",CR,LF,00H
IMNEC:
	DB	"uPD8080A",CR,LF,00H
IM8085:
	DB	"i8085",CR,LF,00H
IMZ80:
	DB	"Z80",CR,LF,00H
	ENDIF

	IF USE_REGCMD

RST7MSG:
	DB	"RST 7",CR,LF,00H

RDTAB:	DW	RDSA,  REGA
	DB	1
	DW	RDSBC, REGBC
	DB	2
	DW	RDSDE, REGDE
	DB	2
	DW	RDSHL, REGHL
	DB	2
	DW	RDSSP, REGSP
	DB	2
	DW	RDSPC, REGPC
	DB	2
	DW	RDSF , REGF
	DB	1

	DW	0000H, 0000H
	DB	0

RDSA:	DB	"A=",00H
RDSBC:	DB	" BC=",00H
RDSDE:	DB	" DE=",00H
RDSHL:	DB	" HL=",00H
RDSSP:	DB	" SP=",00H
RDSPC:	DB	" PC=",00H
RDSF:	DB	" F=",00H

RNTAB:
	DB	'A',1		; "A"
	DW	REGA,RNA
	DB	'B',0FH		; "B?"
	DW	RNTABB,0
	DB	'C',1		; "C"
	DW	REGBC,RNC
	DB	'D',0FH		; "D?"
	DW	RNTABD,0
	DB	'E',1		; "E"
	DW	REGDE,RNE
	DB	'F',1		; "F"
	DW	REGF,RNF
	DB	'H',0FH		; "H?"
	DW	RNTABH,0
	DB	'L',1		; "L"
	DW	REGHL,RNL
	DB	'P',0FH		; "P?"
	DW	RNTABP,0
	DB	'S',0FH		; "S?"
	DW	RNTABS,0

	DB	00H,0		; End mark
	DW	0,0

RNTABB:
	DB	00H,1		; "B"
	DW	REGBC+1,RNB
	DB	'C',2		; "BC"
	DW	REGBC,RNBC

	DB	00H,0		; End mark
	DW	0,0

RNTABD:
	DB	00H,1		; "D"
	DW	REGDE+1,RND
	DB	'E',2		; "DE"
	DW	REGDE,RNDE

	DB	00H,0
	DW	0,0

RNTABH:
	DB	00H,1		; "H"
	DW	REGHL+1,RNH
	DB	'L',2		; "HL"
	DW	REGHL,RNL

	DB	00H,0
	DW	0,0

RNTABP:
	DB	'C',2		; "PC"
	DW	REGPC,RNPC

	DB	00H,0
	DW	0,0

RNTABS:
	DB	'P',2		; "SP"
	DW	REGSP,RNSP

	DB	00H,0
	DW	0,0

RNA:	DB	"A",00H
RNBC:	DB	"BC",00H
RNB:	DB	"B",00H
RNC:	DB	"C",00H
RNDE:	DB	"DE",00H
RND:	DB	"D",00H
RNE:	DB	"E",00H
RNF:	DB	"F",00H
RNHL:	DB	"HL",00h
RNH:	DB	"H",00H
RNL:	DB	"L",00H
RNPC:	DB	"PC",00h
RNSP:	DB	"SP",00h
	
	ENDIF

	IF USE_DEV_8251
	INCLUDE	"dev/dev_8251.asm"
	ENDIF

	IF USE_DEV_SOFT85
	INCLUDE	"dev/dev_soft85.asm"
	ENDIF

;;;
;;; RAM area
;;;

	;; 
	;; Work area
	;;
	
	ORG	WORK_B

INBUF:	DS	BUFLEN		; Line input buffer
DSADDR:	DS	2		; Dump start address
DEADDR:	DS	2		; Dump end address
DSTATE:	DS	1		; Dump state
GADDR:	DS	2		; Go address
SADDR:	DS	2		; Set address
HEXMOD:	DS	1		; HEX file mode
RECTYP:	DS	1		; Record Type
PSPEC:	DS	1		; Processor spec.

	IF USE_REGCMD
REG_B:
REGA:	DS	1
REGBC:	DS	2
REGDE:	DS	2
REGHL:	DS	2
REGSP:	DS	2
REGPC:	DS	2
REGF:	DS	1
REG_E:
	ENDIF
	
ASCPT:	DS	2		; ASC buffer pointer (DUMP), address pointer (PUNCH)
COUNT:	DS	2
	
	END
